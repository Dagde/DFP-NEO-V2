            permissions: ['Staff'],
        });
    }

    const rankOrder: { [key: string]: number } = {
        'WGCDR': 1,
        'SQNLDR': 2,
        'FLTLT': 3,
        'FLGOFF': 4,
        'PLTOFF': 5,
        'Mr': 6
    };

    const sortedQfis = qfis.sort((a, b) => {
        const rankA = rankOrder[a.rank] || 99;
        const rankB = rankOrder[b.rank] || 99;
        if (rankA !== rankB) {
            return rankA - rankB;
        }
        return a.name.localeCompare(b.name);
    });

    return [...sortedQfis, ...simIps.sort((a,b) => a.name.localeCompare(b.name))];
};


// --- COURSE PROGRESS & SCORE SIMULATION ---
const courseProgressRanges: { [key: string]: { start: string; end: string } } = {
  'ADF301': { start: 'BIF4', end: 'BGF23' },
  'ADF302': { start: 'BGF15', end: 'BIF4' },
  'ADF303': { start: 'BGF6', end: 'BGF17' },
  'FIC 210': { start: 'BGF1', end: 'BGF5' },
  'FIC211': { start: 'BGF1', end: 'BGF10' },
  'ADF304': { start: 'BGF1', end: 'BGF10' },
  'ADF305': { start: 'BGF5', end: 'BGF15' },
  'IFF 6': { start: 'BIF1', end: 'BIF5' },
};

const simulateProgressAndScores = (
    trainees: Trainee[],
    syllabus: SyllabusItemDetail[],
    instructors: Instructor[]
): Map<string, Score[]> => {
    const scoreMap = new Map<string, Score[]>();
    const qfiInstructors = instructors.filter(i => i.role === 'QFI');
    const syllabusIds = syllabus.map(s => s.code);

    trainees.forEach(trainee => {
        const range = courseProgressRanges[trainee.course];
        if (!range) {
            scoreMap.set(trainee.fullName, []);
            return;
        }

        const startIndex = syllabusIds.indexOf(range.start);
        const endIndex = syllabusIds.indexOf(range.end);

        if (startIndex === -1 || endIndex === -1 || startIndex >= endIndex) {
             scoreMap.set(trainee.fullName, []);
            return;
        }
        
        // Pick a random event index within the range for the trainee's current progress
        const progressIndex = Math.floor(Math.random() * (endIndex - startIndex + 1)) + startIndex;
        
        const completedEvents = syllabus.slice(0, progressIndex);
        const traineeScores: Score[] = [];
        let latestEventDate: Date | null = null;
        let latestFlightDate: Date | null = null;
        
        // Start generating score dates from a random point in the last 6 months
        const today = new Date();
        const startDate = new Date(today);
        startDate.setDate(today.getDate() - 180);

        completedEvents.forEach(event => {
            // Generate a random score between 1 and 5, or 5 for completed ground events
            let scoreValue: number;
            if (event.code.includes('MB')) {
                // Mass Brief events get score 5 to indicate completion
                scoreValue = 5;
            } else if (event.type === 'Ground School') {
                // Other ground events get score 5 to indicate completion
                scoreValue = 5;
            } else {
                // Flight events get random score between 1 and 5
                scoreValue = Math.floor(Math.random() * 5) + 1;
            }

            const instructor = qfiInstructors.length > 0
                ? qfiInstructors[Math.floor(Math.random() * qfiInstructors.length)].name
                : 'Unknown Instructor';

            // Move date forward for the next event
            const daysToAdd = Math.floor(Math.random() * 3) + 1; // 1 to 3 days
            startDate.setDate(startDate.getDate() + daysToAdd);
            
            const scoreDate = new Date(startDate);
            
            traineeScores.push({
                event: event.code,
                score: scoreValue as Score['score'],
                date: scoreDate.toISOString().split('T')[0],
                instructor,
                notes: scoreValue === 5 ? `Ground event completed for ${event.code}.` : `Simulated score for ${event.code}.`,
                details: scoreValue === 5 ? [] : [{ criteria: 'General Handling', score: scoreValue, comment: 'Auto-generated comment.' }],
            });
            
            latestEventDate = scoreDate;
            if (event.type === 'Flight') {
                latestFlightDate = scoreDate;
            }
        });

        scoreMap.set(trainee.fullName, traineeScores);
        
        // Update trainee object with the latest dates from the simulation
        if (latestEventDate) {
            trainee.lastEventDate = latestEventDate.toISOString().split('T')[0];
        }
        if (latestFlightDate) {
            trainee.lastFlightDate = latestFlightDate.toISOString().split('T')[0];
        } else if (latestEventDate) {
             // If no flights were completed, last flight date is same as last event date (if any)
            trainee.lastFlightDate = latestEventDate.toISOString().split('T')[0];
        }
    });

    return scoreMap;
};

// --- INSTRUCTOR ALLOCATION ALGORITHM ---
const allocateInstructors = (trainees: Trainee[], instructors: Instructor[]): Trainee[] => {
    const allocatableInstructors = instructors.filter(i => i.role === 'QFI');

    if (!allocatableInstructors.length || !trainees.length) return trainees;

    const traineesWithAssignments: Trainee[] = JSON.parse(JSON.stringify(trainees));
    const eligibleTrainees = traineesWithAssignments.filter(t => !t.course.includes('FIC'));

    if (!eligibleTrainees.length) return traineesWithAssignments;
    
    const workload = new Map<string, { primary: number, secondary: number }>();
    allocatableInstructors.forEach(i => workload.set(i.name, { primary: 0, secondary: 0 }));

    const shuffle = <T,>(arr: T[]): T[] => [...arr].sort(() => Math.random() - 0.5);

    const shuffledEligibleTrainees = shuffle(eligibleTrainees);
    let shuffledInstructors = shuffle(allocatableInstructors);

    // Primary Allocation
    const remainingTraineesForPrimary: Trainee[] = [];
    shuffledEligibleTrainees.forEach((trainee, index) => {
        if (index < shuffledInstructors.length) {
            const instructor = shuffledInstructors[index];
            trainee.primaryInstructor = instructor.name;
            workload.get(instructor.name)!.primary++;
        } else {
            remainingTraineesForPrimary.push(trainee);
        }
    });

    let availableForSecondPrimary = shuffle(allocatableInstructors.filter(i => !i.isExecutive));
    remainingTraineesForPrimary.forEach(trainee => {
        if (!availableForSecondPrimary.length) {
            availableForSecondPrimary = shuffle(allocatableInstructors.filter(i => !i.isExecutive));
        }
        const instructor = availableForSecondPrimary.shift()!;
        trainee.primaryInstructor = instructor.name;
        workload.get(instructor.name)!.primary++;
    });

    const getTotalAssignments = (ipName: string): number => {
        const load = workload.get(ipName);
        if (!load) return 999;
        return load.primary + load.secondary;
    };

    const execs = new Set(allocatableInstructors.filter(i => i.isExecutive).map(i => i.name));

    // Secondary Allocation
    for (const trainee of eligibleTrainees) {
        const sortedInstructors = shuffle(allocatableInstructors).sort((a, b) => getTotalAssignments(a.name) - getTotalAssignments(b.name));
        
        for (const instructor of sortedInstructors) {
            if (instructor.name === trainee.primaryInstructor) continue;

            const load = workload.get(instructor.name)!;
            if (execs.has(instructor.name) && (load.primary + load.secondary >= 3 || load.secondary >= 1)) {
                continue;
            }

            trainee.secondaryInstructor = instructor.name;
            load.secondary++;
            break; 
        }
    }

    return traineesWithAssignments;
};
