// DFP-NEO Purple Button Nuclear Fix
// This script aggressively removes purple buttons by directly manipulating inline styles

console.log('DFP-NEO: Purple button fix script loaded');

// Nuclear function to overwrite inline styles
function nukeInlineStyles() {
  const buttons = document.querySelectorAll('button');
  let fixedCount = 0;
  
  buttons.forEach(btn => {
    const text = btn.textContent || '';
    const hasEditEmoji = text.includes('âœï¸');
    const hasSaveEmoji = text.includes('ðŸ’¾');
    
    // If it has Edit or Save emoji, force blue background
    if (hasEditEmoji || hasSaveEmoji) {
      // Directly overwrite the inline style
      btn.style.background = '#3b82f6';
      btn.style.backgroundColor = '#3b82f6';
      btn.style.setProperty('background', '#3b82f6', 'important');
      btn.style.setProperty('background-color', '#3b82f6', 'important');
      
      fixedCount++;
      console.log('DFP-NEO: Nuked purple button:', text.trim());
    }
  });
  
  if (fixedCount > 0) {
    console.log(`DFP-NEO: Fixed ${fixedCount} purple buttons`);
  }
}

// Solo flight fix - replaces duplicate pilot names with "SOLO"
function fixSoloFlights() {
  const tiles = document.querySelectorAll('[data-is-flight-tile="true"]');
  
  tiles.forEach(tile => {
    const textNodes = Array.from(tile.querySelectorAll('div')).map(div => div.textContent);
    const allText = textNodes.join(' ');
    
    // Look for duplicate names (same name appearing twice)
    const namePattern = /([A-Z]+,\s*[A-Z])\s+.*?\1/;
    const match = allText.match(namePattern);
    
    if (match) {
      // Find the second occurrence and replace with SOLO
      const divs = tile.querySelectorAll('div');
      let foundFirst = false;
      
      divs.forEach(div => {
        if (div.textContent.includes(match[1])) {
          if (foundFirst) {
            // This is the second occurrence - replace with SOLO
            const soloSpan = document.createElement('span');
            soloSpan.className = 'bg-yellow-500/20 text-yellow-100 px-1.5 py-0.5 rounded-sm font-bold';
            soloSpan.textContent = 'SOLO';
            soloSpan.style.fontSize = '10px';
            div.textContent = '';
            div.appendChild(soloSpan);
            console.log('DFP-NEO: Fixed solo flight for', match[1]);
          } else {
            foundFirst = true;
          }
        }
      });
    }
  });
}

// Grey course fix - changes non-SCT grey courses to blue
function fixGreyCourses() {
  const tiles = document.querySelectorAll('[data-is-flight-tile="true"]');
  
  tiles.forEach(tile => {
    const bgColor = window.getComputedStyle(tile).backgroundColor;
    const isSCT = tile.textContent.includes('SCT');
    
    // If it's grey (rgb(75, 85, 99) or similar) and not SCT, make it blue
    if (bgColor.includes('75, 85, 99') && !isSCT) {
      tile.style.backgroundColor = '#3b82f6';
      console.log('DFP-NEO: Fixed grey course to blue');
    }
  });
}

// Run initial fixes
setTimeout(() => {
  console.log('DFP-NEO: Running initial fixes...');
  nukeInlineStyles();
  fixSoloFlights();
  fixGreyCourses();
}, 100);

// Run fixes multiple times in the first few seconds
for (let i = 1; i <= 10; i++) {
  setTimeout(() => {
    nukeInlineStyles();
    if (i <= 3) {
      fixSoloFlights();
    }
  }, i * 100);
}

// Continue running fixes every 100ms indefinitely
setInterval(() => {
  nukeInlineStyles();
}, 100);

// Run solo and grey fixes every 2 seconds
setInterval(() => {
  fixSoloFlights();
  fixGreyCourses();
}, 2000);

// MutationObserver to catch dynamically added buttons
const observer = new MutationObserver((mutations) => {
  let shouldFix = false;
  
  mutations.forEach((mutation) => {
    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
      mutation.addedNodes.forEach((node) => {
        if (node.nodeType === 1) { // Element node
          if (node.tagName === 'BUTTON' || node.querySelector('button')) {
            shouldFix = true;
          }
        }
      });
    }
    
    if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
      if (mutation.target.tagName === 'BUTTON') {
        shouldFix = true;
      }
    }
  });
  
  if (shouldFix) {
    nukeInlineStyles();
  }
});

// Start observing
observer.observe(document.body, {
  childList: true,
  subtree: true,
  attributes: true,
  attributeFilter: ['style']
});

console.log('DFP-NEO: Nuclear style fix active - running every 100ms');
console.log('DFP-NEO: MutationObserver watching for new buttons');