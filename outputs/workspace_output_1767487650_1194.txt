  <script>
    // COMPREHENSIVE FIXES FOR DFP-NEO
    
    // FIX 1: Hide only useless sidebar buttons, preserve all functional buttons
    (function() {
      function hideUselessButtons() {
        const buttons = document.querySelectorAll('button');
        buttons.forEach(button => {
          const style = button.getAttribute('style');
          const text = button.textContent.trim();
          const rect = button.getBoundingClientRect();
          
          // Only target bottom-left sidebar buttons
          const isInBottomLeftSidebar = rect.left < 250 && rect.top > 400;
          
          const isPurpleButton = style && (
            style.includes('rgb(118, 75, 162)') || 
            style.includes('118, 75, 162') || 
            style.includes('#764ba2')
          );
          
          // NEVER hide these functional buttons
          const isFunctionalButton = 
            text.includes('Visual Adjust') || 
            text.includes('Save') ||
            text.includes('Cancel') ||
            text.includes('Close') ||
            text.includes('Apply') ||
            text.includes('Confirm') ||
            text.includes('Add') ||
            text.includes('Delete') ||
            text.includes('Update');
          
          // Only hide purple buttons in bottom-left sidebar that are NOT functional
          if (isPurpleButton && isInBottomLeftSidebar && !isFunctionalButton) {
            button.style.setProperty('display', 'none', 'important');
            button.style.setProperty('visibility', 'hidden', 'important');
            button.style.setProperty('opacity', '0', 'important');
            button.style.setProperty('pointer-events', 'none', 'important');
            console.log('ðŸ—‘ï¸ HIDDEN sidebar button:', text);
          }
        });
      }
      
      hideUselessButtons();
      setInterval(hideUselessButtons, 2000);
      
      if (typeof MutationObserver !== 'undefined') {
        const observer = new MutationObserver(hideUselessButtons);
        observer.observe(document.body, {
          childList: true,
          subtree: true
        });
      }
    })();
    
    // FIX 2: Solo flight display - replace duplicate names with SOLO
    (function() {
      function fixSoloFlights() {
        // Find ALL elements that might contain flight information
        const allElements = document.querySelectorAll('*');
        
        allElements.forEach(element => {
          const text = element.textContent;
          const innerHTML = element.innerHTML;
          
          // Skip if no text or already processed
          if (!text || element.dataset.soloFixed === 'true') return;
          
          // Check for solo flight indicators
          const isSolo = /\b(SCT|SOLO|TWR\s+DI)\b/i.test(text);
          
          if (isSolo) {
            // Look for duplicate names pattern
            const namePattern = /([A-Z][a-z]+,\s*[A-Z][a-z]+)(?:\s*\([A-Z]\))?/g;
            const names = [];
            let match;
            
            while ((match = namePattern.exec(text)) !== null) {
              names.push(match[1].trim());
            }
            
            // If we found the same name twice, it's a solo flight with duplicate
            if (names.length >= 2 && names[0] === names[1]) {
              let count = 0;
              const escapedName = names[0].replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const regex = new RegExp('(' + escapedName + ')(?:\\s*\\([A-Z]\\))?', 'g');
              
              const fixedHTML = innerHTML.replace(regex, (match) => {
                count++;
                if (count === 1) {
                  return match; // Keep first occurrence
                } else {
                  return '<span style="color: #fbbf24; font-weight: bold;">SOLO</span>';
                }
              });
              
              if (fixedHTML !== innerHTML) {
                element.innerHTML = fixedHTML;
                element.dataset.soloFixed = 'true';
                console.log('âœ… Fixed SOLO flight:', names[0]);
              }
            }
          }
        });
      }
      
      // Run aggressively at start
      fixSoloFlights();
      setTimeout(fixSoloFlights, 500);
      setTimeout(fixSoloFlights, 1000);
      setTimeout(fixSoloFlights, 2000);
      
      // Then run periodically
      setInterval(fixSoloFlights, 3000);
      
      // Watch for changes
      if (typeof MutationObserver !== 'undefined') {
        const observer = new MutationObserver(() => {
          setTimeout(fixSoloFlights, 200);
        });
        observer.observe(document.body, {
          childList: true,
          subtree: true,
          characterData: true
        });
      }
    })();
    
    // FIX 3: Remove grey color from trainee courses (grey is reserved for SCT)
    (function() {
      function fixCourseColors() {
        // Find all course elements
        const courseElements = document.querySelectorAll('[class*="course"], [data-course], .course-item, [class*="ADF"], [class*="FIC"]');
        
        courseElements.forEach(element => {
          const style = window.getComputedStyle(element);
          const bgColor = style.backgroundColor;
          const text = element.textContent;
          
          // Check if this is a grey course (not SCT)
          const isGrey = bgColor.includes('128, 128, 128') || 
                        bgColor.includes('169, 169, 169') ||
                        bgColor === 'rgb(128, 128, 128)' ||
                        bgColor === 'rgb(169, 169, 169)' ||
                        style.color === 'rgb(128, 128, 128)';
          
          const isSCT = text.includes('SCT');
          
          // If grey but NOT SCT, change to a different color
          if (isGrey && !isSCT) {
            // Change to blue for trainee courses
            element.style.setProperty('background-color', '#3b82f6', 'important'); // blue-500
            element.style.setProperty('color', '#ffffff', 'important');
            console.log('ðŸŽ¨ Fixed grey course color for:', text);
          }
        });
      }
      
      fixCourseColors();
      setInterval(fixCourseColors, 3000);
      
      if (typeof MutationObserver !== 'undefined') {
        const observer = new MutationObserver(fixCourseColors);
        observer.observe(document.body, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ['style', 'class']
        });
      }
    })();
    
    console.log('âœ… DFP-NEO Comprehensive Fixes Loaded');
  </script>
