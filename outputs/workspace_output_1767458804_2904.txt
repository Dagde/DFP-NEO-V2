75-import SyllabusView from './components/SyllabusView';
76-import { InstructorProfileFlyout } from './components/InstructorProfileFlyout';
77-import TraineeProfileFlyout from './components/TraineeProfileFlyout';
78-import PublishConfirmationFlyout from './components/PublishConfirmationFlyout';
79-import CurrencyView from './components/CurrencyView';
80:// FIX: Corrected import to be a named import as per module export.
81-import { CurrencySetupFlyout } from './components/CurrencySetupFlyout';
82-import UnsavedChangesWarning from './components/UnsavedChangesWarning';
83-import PT051View from './components/PT051View';
84-import AuthorisationFlyout from './components/AuthorisationFlyout';
85:// FIX: Corrected import to be a named import as per module export.
86-import { SettingsViewWithMenu } from './components/SettingsViewWithMenu';
87-import AuthorisationView from './components/AuthorisationView';
88-import LocalityChangeFlyout from './components/LocalityChangeFlyout';
89-import { PostFlightView } from './components/PostFlightView';
90-import TraineeLmpView from './components/TraineeLmpView';
91-import AddRemedialPackageFlyout from './components/AddRemedialPackageFlyout';
92-import CourseProgressView from './components/CourseProgressView';
93-import TrainingRecordsView from './components/TrainingRecordsView';
94-import ArchivedCoursesView from './components/ArchivedCoursesView';
95-import NightFlyingInfoFlyout from './components/NightFlyingInfoFlyout';
--
359-  programWithPrimaries: boolean;
360-  traineeLMPs: Map<string, SyllabusItemDetail[]>;
361-  flightTurnaround: number;
362-  ftdTurnaround: number;
363-  cptTurnaround: number;
364:  preferredDutyPeriod: number;
365-  maxCrewDutyPeriod: number;
366-  eventLimits: EventLimits;
367-  sctFlights: SctRequest[];
368-  sctFtds: SctRequest[];
369-  remedialRequests: RemedialRequest[];
370-  sctEvents: string[];
371-  getEventDayNightClassification: (event: { flightNumber: string }, syllabusDetails: SyllabusItemDetail[], sctEvents?: string[]) => 'Day' | 'Night' | 'Day/Night';
372-}
373-
374-// --- DFP Algorithm Helpers (moved outside for re-use in debug) ---
--
422-    startTime: number,
423-    duration: number,
424-    existingEvents: Omit<ScheduleEvent, 'date'>[]
425-): string | null => {
426-    const primaryAreas = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
427:    const secondaryAreas = ['S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
428-
429-    const newEventStart = startTime;
430-    const newEventEnd = startTime + duration;
431-
432-    const isAreaOccupied = (area: string): boolean => {
433-        return existingEvents.some(event => {
434-            if (event.type !== 'flight' || event.area !== area) {
435-                return false;
436-            }
437-            const existingEventStart = event.startTime;
--
457-
458-/**
459- * Get Effective Last Completed Event (ELCE) from yesterday's DFP
460- * 
461- * ELCE Logic: A trainee may have flown an event yesterday that finished successfully,
462: * but the paperwork (PT-051) has not been entered yet. When building tomorrow's program,
463- * the scheduler looks at yesterday's DFP and treats completed events as the trainee's
464- * "Effective Last Completed Event" to ensure correct Next Event determination.
465- * 
466: * Example: Trainee flew BGF2 yesterday at 1100. PT-051 not entered yet, so system
467- * shows last completed as BGF1. ELCE logic finds BGF2 in yesterday's DFP (finished,
468- * not cancelled, not unsuccessful) and uses it to determine Next Event = BGF3.
469- */
470-const getEffectiveLastCompletedEvent = (
471-    traineeName: string,
472-    publishedSchedules: Record<string, ScheduleEvent[]>,
473-    buildDate: string
474-): string | null => {
475-    // Calculate yesterday's date
476-    const buildDateObj = new Date(buildDate + 'T00:00:00Z');
--
757-    
758-    const totalEvents = scheduledEvents.length;
759-    
760-    // Normalize percentages
761-    const normalizePercentages = (percentages: Map<string, number>): Map<string, number> => {
762:        const total = Array.from(percentages.values()).reduce((sum, val) => sum + val, 0);
763-        if (total === 0) return percentages;
764-        const normalized = new Map<string, number>();
765-        percentages.forEach((value, key) => {
766-            normalized.set(key, (value / total) * 100);
767-        });
768-        return normalized;
769-    };
770-    
771-    const normalizedPercentages = normalizePercentages(coursePercentages);
772-    
--
849-    scheduledEvents.forEach(event => {
850-        const hour = Math.floor(event.startTime);
851-        eventsByHour.set(hour, (eventsByHour.get(hour) || 0) + 1);
852-    });
853-    
854:    // Calculate clustering score (0 = perfect uniform, 1 = highly clustered)
855-    const avgEventsPerHour = totalEvents / 24;
856-    let clusteringScore = 0;
857-    eventsByHour.forEach(count => {
858-        clusteringScore += Math.abs(count - avgEventsPerHour);
859-    });
860-    clusteringScore = clusteringScore / (totalEvents * 2); // Normalize to 0-1
861-    
862-    // Calculate uniformity score (inverse of clustering)
863-    const uniformityScore = 1 - clusteringScore;
864-    
--
922-        });
923-    } else if (aircraftUtilization < 60) {
924-        insights.push({
925-            type: 'info',
926-            message: `Aircraft utilization is ${aircraftUtilization.toFixed(0)}%.`,
927:            recommendation: 'Consider reducing available aircraft count or increasing trainee demand.'
928-        });
929-    }
930-    
931-    // Standby events insight
932-    if (standbyCount > 0) {
933-        insights.push({
934-            type: 'warning',
935-            message: `${standbyCount} events placed on standby.`,
936-            recommendation: 'These trainees could not be scheduled due to resource constraints. Consider increasing resources or adjusting schedules.'
937-        });
--
967-        coursePriorities, coursePercentages, availableAircraftCount, ftdCount, cptCount,
968-        courseColors, school, dayStart: flyingStartTime, dayEnd: flyingEndTime,
969-        ftdStart: ftdStartTime, ftdEnd: ftdEndTime,
970-        allowNightFlying, commenceNightFlying, ceaseNightFlying, buildDate,
971-        highestPriorityEvents, programWithPrimaries, traineeLMPs, flightTurnaround,
972:        ftdTurnaround, cptTurnaround, preferredDutyPeriod, maxCrewDutyPeriod,
973-        eventLimits, sctFtds, sctFlights, remedialRequests, sctEvents,
974-        getEventDayNightClassification
975-    } = config;
976-
977-    // --- HELPER FUNCTIONS ---
978-    
979-    // Calculate total duty hours for an instructor including all assigned events (day and night)
980-    const calculateInstructorDutyHours = (instructorName: string, includeProposedEvent?: any): number => {
981-        const eventsToCheck = includeProposedEvent 
982-            ? [...generatedEvents, includeProposedEvent]
--
1152-    });
1153-    
1154-    console.log(`DEBUG Summary: ${includedCount} events INCLUDED, ${skippedCount} events SKIPPED`);
1155-    console.log('DEBUG ===== BUILD ALGORITHM: HIGHEST PRIORITY PROCESSING COMPLETE =====');
1156-    
1157:    // CRITICAL FIX: Assign resources to highest priority events that don't have resourceId
1158-    console.log('DEBUG ===== ASSIGNING RESOURCES TO HIGHEST PRIORITY EVENTS =====');
1159-    generatedEvents.forEach((event) => {
1160-        if (!event.resourceId || event.resourceId === '') {
1161-            // Determine resource type based on event type
1162-            const resourcePrefix = event.type === 'flight' ? 'PC-21 ' : 
1163-                                 event.type === 'ftd' ? 'FTD ' : 
1164-                                 event.type === 'cpt' ? 'CPT ' : 'Ground ';
1165-            const resourceCount = event.type === 'flight' ? availableAircraftCount : 
1166-                                event.type === 'ftd' ? ftdCount : 
1167-                                event.type === 'cpt' ? cptCount : 6;
--
1306-        
1307-        // Find the first Solo-with-TWR-DI event
1308-        const firstIndex = soloWithTwrDiIndices[0];
1309-        const otherIndices = soloWithTwrDiIndices.slice(1);
1310-        
1311:        // Create new list with reordered events
1312:        const reorderedList: Trainee[] = [];
1313-        const soloWithTwrDiToMove: Trainee[] = [];
1314-        
1315-        // Collect all Solo-with-TWR-DI events that need to be moved
1316-        otherIndices.forEach(idx => {
1317-            soloWithTwrDiToMove.push(list[idx]);
1318-        });
1319-        
1320:        // Build the reordered list
1321-        list.forEach((trainee, index) => {
1322-            // Add the trainee if it's not one of the Solo-with-TWR-DI events to be moved
1323-            if (!otherIndices.includes(index)) {
1324:                reorderedList.push(trainee);
1325-                
1326-                // If this is the first Solo-with-TWR-DI event, insert all others after it
1327-                if (index === firstIndex) {
1328:                    reorderedList.push(...soloWithTwrDiToMove);
1329-                }
1330-            }
1331-        });
1332-        
1333:        return reorderedList;
1334-    };
1335-    
1336-    // Apply reordering only to the flight list (Day Next Event List)
1337-    nextEventLists.flight = reorderSoloWithTwrDi(nextEventLists.flight);
1338-    setProgress({ message: 'Allocating course slots...', percentage: 30 });
1339-    
1340-    // Helper: Normalize percentages to sum to 100%
1341-    const normalizePercentages = (percentages: Map<string, number>): Map<string, number> => {
1342:        const total = Array.from(percentages.values()).reduce((sum, val) => sum + val, 0);
1343-        if (total === 0) return percentages; // Avoid division by zero
1344-        
1345-        const normalized = new Map<string, number>();
1346-        percentages.forEach((value, key) => {
1347-            normalized.set(key, (value / total) * 100);
1348-        });
1349-        return normalized;
1350-    };
1351-    
1352-    // Helper: Enforce minimum percentage (5%) for all courses
--
1559-        endTimeBoundary: number,
1560-        standbyPrefix: string | null,
1561-        isNightPass: boolean
1562-    ) => {
1563-        // Time increments for slot hunting:
1564:        // - Flight: 5 minutes (staggered departures to avoid all aircraft taxiing at once)
1565-        // - Ground/CPT: 15 minutes (represents minimum gap between end of one ground school and start of next)
1566-        const timeIncrement = type === 'flight' ? 5 / 60 : 15 / 60;
1567-        const listName = `${isNightPass ? 'BNF' : type.toUpperCase()} ${isPlusOne ? 'Next+1' : 'Next'}`;
1568-        setProgress({ message: `Placing ${listName} events...`, percentage: 40 + (['flight', 'ftd', 'cpt', 'ground'].indexOf(type) * 10) });
1569-        
1570-        let unplacedTrainees = [...list];
1571-        let placedThisPass = true;
1572-
1573-        const segments: { start: number, end: number, count: number }[] = [];
1574-        if ((type === 'cpt' || type === 'ground') && !isNightPass) {
--
1659-        isPlusOne: boolean
1660-    ): ScheduleEventResult => {
1661-        
1662-        const traineeCounts = eventCounts.get(trainee.fullName)!;
1663-        
1664:        // CRITICAL FIX: For night flying BNF events, allow 2 flights per night
1665-        const isBnfEvent = syllabusItem.code.startsWith('BNF') && syllabusItem.type === 'Flight';
1666-        const bnfFlightLimit = isBnfEvent ? 2 : eventLimits.trainee.maxFlightFtd;
1667-        
1668-        if (type === 'flight' || type === 'ftd') {
1669-             if (traineeCounts.flightFtd >= bnfFlightLimit) return null;
1670-        } else {
1671-             if (traineeCounts.ground >= 2) return null;
1672-        }
1673-        
1674-        // Also check total event count for trainees (Flight + FTD + CPT + Ground = max 3 events for staff)
--
1685-            isPlusOneCheck: boolean
1686-        ): Instructor | null => {
1687-            const isBnfEvent = syllabusItemForCheck.code.startsWith('BNF');
1688-            
1689-            if (isBnfEvent) {
1690:                const pairedInstructorName = nightPairings.get(traineeForCheck.fullName);
1691:                if (!pairedInstructorName) return null;
1692-                
1693:                const instructor = instructors.find(i => i.name === pairedInstructorName);
1694-                if (!instructor) return null;
1695-
1696-                if (isPersonStaticallyUnavailable(instructor, proposedBookingWindow.start, proposedBookingWindow.end, buildDate, 'flight')) return null;
1697-
1698-                const ipCounts = eventCounts.get(instructor.name)!;
1699-                const execLimit = eventLimits.exec.maxFlightFtd;
1700-                const flightFtdLimit = eventLimits.instructor.maxFlightFtd;
1701-                const totalEventLimit = eventLimits.instructor.maxTotal;
1702-
1703:                // CRITICAL FIX: Check soft duty limit BEFORE any other checks
1704-                const proposedEvent = {
1705-                    ...proposedBookingWindow,
1706-                    instructor: instructor.name,
1707-                    flightNumber: syllabusItemForCheck.id,
1708-                    type: syllabusItemForCheck.type
1709-                };
1710-                const currentDutyHours = calculateInstructorDutyHours(instructor.name, proposedEvent);
1711-                
1712:                if (currentDutyHours > preferredDutyPeriod) {
1713:                    console.log(`SOFT LIMIT VIOLATION: ${instructor.name} would exceed ${preferredDutyPeriod}hrs (current: ${currentDutyHours.toFixed(2)}hrs)`);
1714-                    return null;
1715-                }
1716-
1717-                if (instructor.isExecutive) {
1718-                    if (isNightPass) {
1719-                        // For night pass, execs can fly up to the total event limit
1720-                        if ((ipCounts.flightFtd + ipCounts.ground + ipCounts.cpt) >= totalEventLimit) return null;
1721-                    } else {
1722-                        // For day pass, execs have a stricter flight/FTD limit
1723-                        if (ipCounts.flightFtd >= execLimit) return null;
--
1757-                        const crewTurnaround = (firstSyllabus?.postFlightTime || 0) + (secondSyllabus.preFlightTime || 0);
1758-                        
1759-                        // The earliest the INSTRUCTOR is available is after their first debrief
1760-                        const earliestBriefStartTimeForInstructor = firstNightEvent.startTime + firstNightEvent.duration + (firstSyllabus?.postFlightTime || 0);
1761-                        
1762:                        // The proposed start time is for the flight itself. We need to check the brief starts after the required debrief ends.
1763-                        const proposedBriefStartTime = startTime - (syllabusItemForCheck.preFlightTime || 0);
1764-
1765-                        if (proposedBriefStartTime < earliestBriefStartTimeForInstructor) {
1766-                            return null; // Instructor is not available yet due to crew turnaround
1767-                        }
1768-                    }
1769-                }
1770-
1771-                return instructor;
1772-            }
--
1785-                // NEW RULE: COMPLETE separation - NO day events for instructors with night events
1786-                const availableQfis = instructors.filter(i => 
1787-                    i.role === 'QFI' && 
1788-                    !(nextEventLists.bnf.length >= 2 && isPersonScheduledForNightEvents(i.name))
1789-                );
1790:                let orderedQfis: Instructor[] = [];
1791-                
1792-                if (programWithPrimaries) {
1793-                    const pNames = [traineeForCheck.primaryInstructor, traineeForCheck.secondaryInstructor].filter(Boolean);
1794-                    const primaries = availableQfis.filter(i => pNames.includes(i.name));
1795-                    const others = availableQfis.filter(i => !pNames.includes(i.name));
1796-                    
1797-                    primaries.sort((a, b) => (eventCounts.get(a.name)?.flightFtd || 0) - (eventCounts.get(b.name)?.flightFtd || 0));
1798-                    others.sort((a, b) => (eventCounts.get(a.name)?.flightFtd || 0) - (eventCounts.get(b.name)?.flightFtd || 0));
1799-                    
1800:                    orderedQfis = [...primaries, ...others];
1801-                } else {
1802:                    orderedQfis = availableQfis.sort((a, b) => (eventCounts.get(a.name)?.flightFtd || 0) - (eventCounts.get(b.name)?.flightFtd || 0));
1803-                }
1804-                
1805:                candidates = [...simIps, ...orderedQfis];
1806-            } else {
1807-                const qualified = instructors.filter(ip => {
1808-                    const isQFI = ip.role === 'QFI';
1809-                    if (type === 'flight' && !isQFI) return false;
1810-                    // This applies to ALL event types including CPT and ground
1811-                    // NEW RULE: COMPLETE separation - NO day events for instructors with night events
1812-                    if (nextEventLists.bnf.length >= 2 && isPersonScheduledForNightEvents(ip.name)) return false;
1813-                    return true;
1814-                });
1815-
--
1840-                const eventTypeForCheck = type === 'cpt' ? 'ground' : type;
1841-                if (isPersonStaticallyUnavailable(ip, proposedBookingWindow.start, proposedBookingWindow.end, buildDate, eventTypeForCheck)) continue;
1842-                
1843-                const ipCounts = eventCounts.get(ip.name)!;
1844-                
1845:                // CRITICAL FIX: Check soft duty limit for all instructor assignments
1846-                const proposedEvent = {
1847-                    ...proposedBookingWindow,
1848-                    instructor: ip.name,
1849-                    flightNumber: syllabusItemForCheck.id,
1850-                    type: syllabusItemForCheck.type
1851-                };
1852-                const currentDutyHours = calculateInstructorDutyHours(ip.name, proposedEvent);
1853-                
1854:                if (currentDutyHours > preferredDutyPeriod) {
1855:                    console.log(`SOFT LIMIT VIOLATION: ${ip.name} would exceed ${preferredDutyPeriod}hrs (current: ${currentDutyHours.toFixed(2)}hrs)`);
1856-                    continue;
1857-                }
1858-                
1859-                // NEW RULE: Ground event limits based on Flight/FTD activity
1860-                // If instructor has Flight or FTD events: max 1 ground event
1861-                // If instructor has no Flight or FTD events: max 4 ground events
1862-                if (eventTypeForCheck === 'ground') {
1863-                    const maxGroundEvents = ipCounts.flightFtd > 0 ? 1 : 4;
1864-                    if (ipCounts.ground >= maxGroundEvents) continue;
1865-                }
--
1907-                return ip;
1908-            }
1909-            return null;
1910-        };
1911-        
1912:        // CRITICAL FIX: Skip instructor assignment for solo flights
1913-        const isSoloFlight = syllabusItem.sortieType === 'Solo';
1914-        
1915-        let instructor: Instructor | null = null;
1916-        if (!isSoloFlight) {
1917-            instructor = findAvailableInstructor(trainee, syllabusItem, isPlusOne);
1918-            if (!instructor) return null;
1919-        }
1920-        
1921-        let resourceId: string | null = null;
1922-        const resourcePrefix = type === 'flight' ? 'PC-21 ' : type === 'ftd' ? 'FTD ' : type === 'cpt' ? 'CPT ' : 'Ground ';
1923-        const resourceCount = type === 'flight' ? availableAircraftCount : type === 'ftd' ? ftdCount : type === 'cpt' ? cptCount : 6;
1924-        
1925:        // Debug logging removed to reduce console noise
1926-        
1927-        for (let i = 1; i <= resourceCount; i++) {
1928-            const id = `${resourcePrefix}${i}`;
1929-            const resourceIsOccupied = generatedEvents.some(e => {
1930-                if (e.resourceId !== id) return false;
1931-                
1932-                let turnaround = 0;
1933-                if (e.type === 'flight') {
1934-                    const isExistingEventNight = e.flightNumber.startsWith('BNF');
1935-                    if (isNightPass && isExistingEventNight) {
--
2017-    setProgress({ message: 'Scheduling Duty Supervisors...', percentage: 40 });
2018-    
2019-    // Duty Supervisor MUST cover entire Day flying window regardless of flight schedule
2020-    const dayFlights = generatedEvents.filter(e => e.type === 'flight' && !e.resourceId.startsWith('STBY') && !e.resourceId.startsWith('BNF-STBY'));
2021-    
2022:    // Duty Supervisor covers entire configured day flying window
2023-    const dutySupStartTime = flyingStartTime;
2024-    const dutySupEndTime = flyingEndTime;
2025-    
2026-    // Always schedule Duty Supervisor for day window, even if no flights
2027-    if (dutySupStartTime >= dutySupEndTime) {
2028-        setProgress({ message: 'Invalid day flying window', percentage: 90 });
2029-        // Continue to night flying setup even if day window is invalid
2030-    }
2031-    
2032-    const lastFlightEndTime = dutySupEndTime;
2033-    
2034:    // CRITICAL FIX: Determine night duty supervisor FIRST before scheduling day duty supervisors
2035-    // This ensures they are marked as intendedNightStaff and excluded from day scheduling
2036-    let nightDutySup: Instructor | null = null;
2037-    if (nextEventLists.bnf.length >= 2) {
2038-        console.log('ðŸŒ™ Pre-selecting night duty supervisor to prevent day assignments...');
2039-        const nightFlyingInstructorNames = new Set(Array.from(nightPairings.values()));
2040-        const nightSupPool = instructors.filter(s => 
2041-            (s.isFlyingSupervisor || s.unavailability.some(u => u.reason === 'TMUF - Ground Duties only' && buildDate >= u.startDate && buildDate < u.endDate)) &&
2042-            !nightFlyingInstructorNames.has(s.name)
2043-        );
2044-        
--
2082-    // NEW ALGORITHM: Randomize supervisor selection instead of alphabetical/order-based
2083-    const shuffledNormalSupervisors = [...normalSupervisors].sort(() => 0.5 - Math.random());
2084-    const sortedSupervisors = [...tmuffSupervisors, ...shuffledNormalSupervisors];
2085-
2086-    let currentSupTime = dutySupStartTime;
2087:    // CRITICAL FIX: Schedule Duty Supervisors for the ENTIRE day window, not just when flights are active
2088-    console.log(`Duty Supervisor Allocation - Covering entire day window: ${dutySupStartTime} to ${dutySupEndTime}`);
2089-    while (currentSupTime < dutySupEndTime) {
2090:        const isBlockCovered = generatedEvents.some(e => e.resourceId === 'Duty Sup' && currentSupTime >= e.startTime && currentSupTime < e.startTime + e.duration);
2091:        if (isBlockCovered) {
2092-            currentSupTime += 0.5;
2093-            continue;
2094-        }
2095-
2096-        let bestSupervisor: Instructor | null = null;
2097-        let maxDuration = 0;
2098-
2099-        // NEW RULE: Prefer supervisors with 0 duty sup events, only use those with 1+ if no one else available
2100-        const supervisorsWithNoDutySup = sortedSupervisors.filter(s => eventCounts.get(s.name)!.dutySup === 0);
2101-        const supervisorsWithDutySup = sortedSupervisors.filter(s => eventCounts.get(s.name)!.dutySup > 0);
--
2111-            if (ipCounts.dutySup >= dutySupEventCount) continue;
2112-            if ((ipCounts.flightFtd + ipCounts.ground + ipCounts.cpt + ipCounts.dutySup) >= totalEventCount) continue;
2113-            
2114-            if (isPersonStaticallyUnavailable(sup, currentSupTime, currentSupTime + 0.1, buildDate, 'duty_sup')) continue;
2115-
2116:            // CRITICAL FIX: Use the new helper function to calculate duty hours
2117-            // Check soft duty limit before assigning any duty supervisor time
2118-            const proposedDutySupEvent = {
2119-                startTime: currentSupTime,
2120-                duration: 2.0, // Standard 2-hour duty supervisor assignment
2121-                flightNumber: 'Duty Sup',
2122-                type: 'ground' as const
2123-            };
2124-            
2125-            const totalDutyHours = calculateInstructorDutyHours(sup.name, proposedDutySupEvent);
2126-            
2127:            console.log(`Duty Sup Check - ${sup.name}: Total Duty = ${totalDutyHours.toFixed(2)}hrs, Soft Limit = ${preferredDutyPeriod}hrs`);
2128-            
2129:            if (totalDutyHours > preferredDutyPeriod) {
2130:                console.log(`Skipping ${sup.name} - would exceed soft limit of ${preferredDutyPeriod}hrs`);
2131-                continue;
2132-            }
2133-            
2134-            const hasOverlapAtStart = generatedEvents
2135-                .filter(e => !e.resourceId.startsWith('STBY') && !e.resourceId.startsWith('BNF-STBY'))
2136-                .some(e => {
2137-                    if (!getPersonnel(e).includes(sup.name)) return false;
2138-                    const bookingWindow = getEventBookingWindowForAlgo(e, syllabusDetails);
2139-                    return currentSupTime < bookingWindow.end && (currentSupTime + 0.1) > bookingWindow.start;
2140-                });
2141-            if (hasOverlapAtStart) continue;
2142-
2143-            let potentialDuration = 0;
2144-            const targetDuration = 2.0;
2145-
2146:            // CRITICAL FIX: Don't extend duty supervisor beyond day window end or soft duty limit
2147-            for (let t = currentSupTime; t < dutySupEndTime; t += 0.25) {
2148-                if (potentialDuration >= targetDuration) break;
2149-                
2150-                const proposedEnd = t + 0.25;
2151-                if (isPersonStaticallyUnavailable(sup, t, proposedEnd, buildDate, 'duty_sup')) break;
2152-                
2153-                // Check if adding this additional duty time would exceed the soft limit
2154-                const proposedDutySupEvent = {
2155-                    startTime: currentSupTime,
2156-                    duration: proposedEnd - currentSupTime,
--
2168-                    
2169-                    const dayStart = bookingWindows[0].start;
2170-                    const dayEnd = bookingWindows[bookingWindows.length - 1].end;
2171-                    const totalDutyHours = dayEnd - dayStart;
2172-                    
2173:                    if (totalDutyHours > preferredDutyPeriod) {
2174-                        // Adding more time would exceed soft limit, stop extending
2175-                        break;
2176-                    }
2177-                }
2178-                
2179-                const hasFutureOverlap = generatedEvents
2180-                     .filter(e => !e.resourceId.startsWith('STBY') && !e.resourceId.startsWith('BNF-STBY'))
2181-                     .some(e => {
2182-                         if (!getPersonnel(e).includes(sup.name)) return false;
2183-                         const bookingWindow = getEventBookingWindowForAlgo(e, syllabusDetails);
--
2202-            });
2203-            eventCounts.get(bestSupervisor.name)!.dutySup++;
2204-            console.log(`Duty Sup assigned: ${bestSupervisor.name} from ${currentSupTime} to ${currentSupTime + maxDuration}`);
2205-            currentSupTime += maxDuration;
2206-        } else {
2207:            // CRITICAL FIX: If no supervisor available, we MUST still fill the gap
2208-            // This prevents gaps in duty supervisor coverage
2209-            console.log(`WARNING: No Duty Supervisor available for ${currentSupTime} to ${currentSupTime + 0.5} - GAP in coverage!`);
2210-            currentSupTime += 0.5;
2211-        }
2212-    }
2213-
2214-    // 2. Schedule DUTY SUP for Night Flying window (if 2+ BNF trainees)
2215-    if (nextEventLists.bnf.length >= 2 && nightDutySup) {
2216-        setProgress({ message: 'Scheduling Night Duty Supervisor...', percentage: 42 });
2217-        console.log(`Scheduling night duty supervisor: ${nightDutySup.name}`);
--
2748-                console.log(`FTD STBY: Could not place ${trainee.fullName} - all STBY lines full`);
2749-            }
2750-        }
2751-        
2752-        const ftdStbyEvents = generatedEvents.filter(e => e.type === 'ftd' && e.resourceId.startsWith('STBY'));
2753:        console.log(`FTD STBY complete: Placed ${ftdStbyEvents.length} events across ${currentStbyLine - 1} STBY lines`);
2754-    }
2755-    
2756-    setProgress({ message: 'Shuffling events for distribution...', percentage: 95 });
2757-    
2758-    // Helper: Shuffle array randomly (Fisher-Yates algorithm)
2759-    const shuffleArray = <T,>(array: T[]): T[] => {
2760-        const shuffled = [...array];
2761-        for (let i = shuffled.length - 1; i > 0; i--) {
2762-            const j = Math.floor(Math.random() * (i + 1));
2763-            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
--
3115-    });
3116-
3117-    // Phrase Bank State
3118-    const [phraseBank, setPhraseBank] = useState<PhraseBank>(DEFAULT_PHRASE_BANK);
3119-
3120:    // Published Schedules State (must be declared before buildResources)
3121-    const [publishedSchedules, setPublishedSchedules] = useState<Record<string, ScheduleEvent[]>>({});
3122-    
3123-    // NDB state
3124-    const [nextDayBuildEvents, setNextDayBuildEvents] = useState<Omit<ScheduleEvent, 'date'>[]>([]);
3125-    const [buildDfpDate, setBuildDfpDate] = useState<string>(() => {
3126-        const tomorrow = new Date();
3127-        tomorrow.setDate(tomorrow.getDate() + 1);
3128-        return getLocalDateString(tomorrow);
3129-    });
3130-    const [lastBuildAnalysis, setLastBuildAnalysis] = useState<BuildAnalysis | null>(null);
--
3136-    const [ftdStartTime, setFtdStartTime] = useState(8.0); // 08:00
3137-    const [ftdEndTime, setFtdEndTime] = useState(17.0); // 17:00
3138-    const [allowNightFlying, setAllowNightFlying] = useState(true);
3139-    const [commenceNightFlying, setCommenceNightFlying] = useState(18.5); // 18:30
3140-    const [ceaseNightFlying, setCeaseNightFlying] = useState(23.5); // 23:30
3141:    const [preferredDutyPeriod, setPreferredDutyPeriod] = useState(8);
3142-    const [maxCrewDutyPeriod, setMaxCrewDutyPeriod] = useState(10);
3143-    const [maxDispatchPerHour, setMaxDispatchPerHour] = useState(8);
3144-    const [flightTurnaround, setFlightTurnaround] = useState(1.2);
3145-    const [ftdTurnaround, setFtdTurnaround] = useState(0.5);
3146-    const [cptTurnaround, setCptTurnaround] = useState(0.5);
3147-    const [isBuildingDfp, setIsBuildingDfp] = useState(false);
3148-    const [dfpBuildProgress, setDfpBuildProgress] = useState({ message: '', percentage: 0 });
3149-    const [showDateWarning, setShowDateWarning] = useState(false);
3150-    const [unavailabilityNotifications, setUnavailabilityNotifications] = useState<string[]>([]);
3151-    const [isPriorityEventCreation, setIsPriorityEventCreation] = useState(false);
3152-    const [highestPriorityEvents, setHighestPriorityEvents] = useState<ScheduleEvent[]>([]);
3153-    const [programWithPrimaries, setProgramWithPrimaries] = useState(true);
3154-    
3155-    // Cancellation Records State
3156-    const [cancellationRecords, setCancellationRecords] = useState<CancellationRecord[]>(() => {
3157:        const stored = localStorage.getItem('cancellationRecords');
3158:        return stored ? JSON.parse(stored) : [];
3159-    });
3160-    
3161-    // Cancellation Codes State
3162-    const [cancellationCodes, setCancellationCodes] = useState<CancellationCode[]>(() => {
3163:        const stored = localStorage.getItem('cancellationCodes');
3164:        if (stored) {
3165:            return JSON.parse(stored);
3166-        }
3167-        // Initialize with default codes if not found
3168-        localStorage.setItem('cancellationCodes', JSON.stringify(initialCancellationCodes));
3169-        return initialCancellationCodes;
3170-    });
3171-    const [showNightFlyingInfo, setShowNightFlyingInfo] = useState(false);
3172-    const [nightFlyingTraineeCount, setNightFlyingTraineeCount] = useState(0);
3173-    const [showUnavailabilityReport, setShowUnavailabilityReport] = useState(false);
3174-
3175-    // Oracle State
--
3282-        let deploymentCount = 0;
3283-        
3284-        console.log('buildResources - Current view:', activeView, 'Current date:', date);
3285-        
3286-        if (activeView === 'Program Schedule' || activeView === 'DailyFlyingProgram' || activeView === 'InstructorSchedule' || activeView === 'TraineeSchedule') {
3287:            // Check all events across all dates for deployments that overlap with current date
3288-            const todayStart = new Date(`${date}T00:00:00Z`).getTime();
3289-            const todayEnd = new Date(todayStart);
3290-            todayEnd.setUTCDate(todayEnd.getUTCDate() + 1);
3291-            const todayEndTime = todayEnd.getTime();
3292-            
3293-            const allEvents: ScheduleEvent[] = Object.values(publishedSchedules).flat();
3294-            const overlappingDeployments = allEvents.filter(event => {
3295-                if (event.type !== 'deployment') return false;
3296-                
3297-                const eventStartMs = new Date(`${event.date}T00:00:00Z`).getTime() + (event.startTime * 60 * 60 * 1000);
--
3309-            console.log('Next day build deployment events:', deploymentEvents);
3310-        }
3311-        
3312-        console.log('deploymentCount:', deploymentCount);
3313-        
3314:        // Build PC-21 resources, replacing the last N with "Deployed X" if needed
3315-        const pc21Resources = Array.from({ length: pc21Count }, (_, i) => {
3316-            const deploymentIndex = pc21Count - i;
3317-            if (deploymentIndex <= deploymentCount) {
3318-                const deployNum = deploymentCount - deploymentIndex + 1;
3319-                console.log(`Transforming PC-21 ${i + 1} to Deployed ${deployNum}`);
3320-                return `Deployed ${deployNum}`;
3321-            }
3322-            return `PC-21 ${i + 1}`;
3323-        });
3324-        
--
3370-        console.log('Built all resources:', allResources, 'STBY lines:', stbyLineCount);
3371-        return allResources;
3372-    }, [availableFtdCount, availableCptCount, availableAircraftCount, date, activeView, publishedSchedules, nextDayBuildEvents]);
3373-    
3374-    // Filter resources to only show those with events (for schedule views)
3375:    const getFilteredResources = useCallback((events: ScheduleEvent[], allResources: string[]) => {
3376-        // Safety check: if no events, return empty array
3377-        if (!events || events.length === 0) {
3378-            console.log('No events, returning empty resources');
3379-            return [];
3380-        }
3381-        
3382-        // Map each event to its resource category label
3383-        const resourceLabels: string[] = [];
3384-        
3385-        for (const event of events) {
--
3443-        }
3444-    }, [sctFlights, sctFtds, activeView]);
3445-
3446-    // Sync priority events when remedial requests change
3447-    useEffect(() => {
3448:        console.log('ðŸ”„ useEffect triggered - activeView:', activeView, 'remedialRequests count:', remedialRequests.filter(r => r.forceSchedule).length);
3449-        if (activeView === 'Priorities' || activeView === 'ProgramData') {
3450-            console.log('âœ… Active view matches, calling sync...');
3451-            syncPriorityEventsWithSctAndRemedial();
3452-        } else {
3453-            console.log('â¸ï¸ Not syncing - activeView is:', activeView);
3454-        }
3455-    }, [remedialRequests, activeView]);
3456-
3457-    // Save timezone offset to localStorage
3458-    useEffect(() => {
--
3531-        const todayStart = new Date(`${date}T00:00:00Z`).getTime();
3532-        const todayEnd = new Date(todayStart);
3533-        todayEnd.setUTCDate(todayEnd.getUTCDate() + 1);
3534-        const todayEndTime = todayEnd.getTime();
3535-    
3536:        // FIX: Explicitly type allEvents to aid TypeScript's inference.
3537-        const allEvents: ScheduleEvent[] = Object.values(publishedSchedules).flat();
3538-    
3539-        for (const event of allEvents) {
3540-            let eventStartMs: number, eventEndMs: number;
3541-    
3542-            eventStartMs = new Date(`${event.date}T00:00:00Z`).getTime() + (event.startTime * 60 * 60 * 1000);
3543-            eventEndMs = eventStartMs + (event.duration * 60 * 60 * 1000);
3544-    
3545-            if (eventStartMs < todayEndTime && eventEndMs > todayStart) {
3546-                const segmentStartMs = Math.max(eventStartMs, todayStart);
--
3740-            console.log(`   Instructor: "${targetEvent.instructor || 'EMPTY'}"`);
3741-            console.log(`   Personnel:`, getPersonnel(targetEvent));
3742-        }
3743-
3744-        // Get turnaround time for target event
3745:        let requiredTurnaround = 0;
3746:        if (targetEvent.type === 'flight') requiredTurnaround = flightTurnaround;
3747:        else if (targetEvent.type === 'ftd') requiredTurnaround = ftdTurnaround;
3748:        else if (targetEvent.type === 'cpt' || (targetEvent.type === 'ground' && targetEvent.flightNumber.includes('CPT'))) requiredTurnaround = cptTurnaround;
3749-
3750-        // Check turnaround conflicts - only with events on same resource
3751-        const sameResourceEvents = validEvents.filter(e => e.resourceId === targetEvent.resourceId);
3752-        sameResourceEvents.sort((a, b) => a.startTime - b.startTime);
3753-
3754-        for (let i = 0; i < sameResourceEvents.length; i++) {
3755-            const event = sameResourceEvents[i];
3756-            
3757-            // Check if targetEvent comes after this event
3758-            if (targetEvent.startTime > event.startTime) {
3759-                const gap = targetEvent.startTime - (event.startTime + event.duration);
3760:                if (gap < requiredTurnaround) {
3761-                    return { 
3762-                        hasConflict: true, 
3763-                        conflictingEventId: event.id, 
3764-                        conflictType: 'turnaround',
3765-                        conflictedPersonnel: null 
3766-                    };
3767-                }
3768-            }
3769-            
3770-            // Check if targetEvent comes before this event
--
4012-            // console.log('ðŸ”´ ========== CONFLICT CHECK END (EMPTY) ==========');
4013-            return conflictingEventIds;
4014-        }
4015-
4016-        // console.log('ðŸ”´ Total events to check:', eventsForDate.length);
4017:           // CRITICAL FIX: Ensure ALL events have pilot field before conflict check
4018-           eventsForDate.forEach(event => {
4019-               if (!event.pilot) {
4020-                   // If no pilot field, set it based on event type
4021-                   if (event.instructor) {
4022-                       event.pilot = event.instructor;
4023-                   } else if (event.student) {
4024-                       event.pilot = event.student;
4025-                   }
4026-               }
4027-           });
--
4060-            }
4061-
4062-            // Get the Master LMP for this event
4063-            const syllabusItem = syllabusDetails.find(item => item.id === event.flightNumber);
4064-            if (!syllabusItem || syllabusItem.twrDiReqd !== 'YES') {
4065:                // TWR DI not required, skip this validation rule
4066-                continue;
4067-            }
4068-
4069-            // Find TWR DI events scheduled on the TWR DI resource line
4070-            const twrDiEvents = eventsForDate.filter(e => 
4071-                e.eventCategory === 'twr_di' && 
4072-                e.type === 'flight'
4073-            );
4074-
4075-            // Check if any TWR DI event provides full coverage
--
4120-            }
4121-
4122-            // Get the Master LMP for this event
4123-            const syllabusItem = syllabusDetails.find(item => item.id === event.flightNumber);
4124-            if (!syllabusItem || syllabusItem.twrDiReqd !== 'YES') {
4125:                // TWR DI not required, skip this validation rule
4126-                continue;
4127-            }
4128-
4129-            // Find TWR DI events scheduled on the TWR DI resource line
4130-            const twrDiEvents = nextDayBuildEvents.filter(e => 
4131-                e.eventCategory === 'twr_di' && 
4132-                e.type === 'flight'
4133-            );
4134-
4135-            // Check if any TWR DI event provides full coverage
--
4375-                return prevLMPs;
4376-            }
4377-    
4378-            cleanedLmp.splice(insertionIndex + 1, 0, ...remedialPackageItems);
4379-    
4380:            // CRITICAL FIX: Update ALL subsequent events that depend on the failed event
4381-            // Previously only updated the first one, causing events beyond the first to be schedulable
4382-            // before completing the remedial package
4383-            const subsequentEvents = cleanedLmp.filter(item => item.prerequisites.includes(eventToRemediate.id));
4384-            
4385-            subsequentEvents.forEach(subsequentEvent => {
4386-                const prereqIndex = subsequentEvent.prerequisites.indexOf(eventToRemediate.id);
4387-                if (prereqIndex !== -1) {
4388-                    subsequentEvent.prerequisites[prereqIndex] = reFlyEvent.id;
4389-                    console.log(`âœ… Updated prerequisite for ${subsequentEvent.code}: ${eventToRemediate.id} â†’ ${reFlyEvent.id}`);
4390-                }
--
4548-        const newDateStr = currentDate.toISOString().split('T')[0];
4549-        setDate(newDateStr);
4550-    };
4551-
4552-    const onSavePT051Assessment = (assessment: Pt051Assessment) => {
4553:        // Use traineeFullName for the key to ensure consistency across the app
4554-        const saveKey = `${assessment.traineeFullName}_${assessment.eventId}_PT051`;
4555-        setPt051Assessments(prev => new Map(prev).set(saveKey, assessment));
4556-        
4557-        // Log to audit trail
4558-        const changes = [
4559-            assessment.overallGrade ? `Overall Grade: ${assessment.overallGrade}` : null,
4560-            assessment.overallResult ? `Overall Result: ${assessment.overallResult}` : null,
4561-            assessment.dcoResult ? `DCO Result: ${assessment.dcoResult}` : null,
4562-            assessment.overallComments ? `Comments: ${assessment.overallComments.substring(0, 50)}...` : null
4563-        ].filter(Boolean).join(', ');
--
4684-            setIsEditingDefault(true);
4685-            setHighlightedField(null);
4686-            setIsPriorityEventCreation(!!options.isPriority);
4687-            setOracleContextForModal(options.oracleContext || null);
4688-        } else {
4689:            // CRITICAL FIX: Always fetch the latest version of the event from the schedule
4690-            // This ensures we get the most up-to-date data, especially after NEO remedies
4691-            const isNextDayContext = ['NextDayBuild', 'Priorities', 'ProgramData', 'NextDayInstructorSchedule', 'NextDayTraineeSchedule'].includes(activeView);
4692-            const currentEvents = isNextDayContext ? nextDayBuildEvents.map(e => ({ ...e, date: buildDfpDate })) : eventsForDate;
4693-            const latestEvent = currentEvents.find(e => e.id === event.id);
4694-            
4695-            // Use the latest version if found, otherwise fall back to the passed event
4696-            const eventToOpen = latestEvent || event;
4697-            
4698-            setSelectedEvent(eventToOpen);
4699-            setIsEditingDefault(false);
--
4906-                    // Track already assigned events in this batch
4907-                    const alreadyAssigned: ScheduleEvent[] = [];
4908-                    
4909-                    eventsToSave.forEach(e => {
4910-                        // Assign resourceId based on event type
4911:                        // For deployments, always reassign to get correct numbered resource
4912-                        if (!e.resourceId || e.type === 'deployment') {
4913-                            const allEventsForDate = publishedSchedules[mainEvent.date] || [];
4914-                            // Include already assigned events from this batch
4915-                            const eventsToCheck = [...allEventsForDate, ...alreadyAssigned];
4916-                            const assignedResourceId = findAvailableResourceId(e, eventsToCheck);
4917-                            console.log(`Assigning resourceId to ${e.type} event:`, assignedResourceId);
4918-                            e.resourceId = assignedResourceId;
4919-                            // Add to already assigned list
4920-                            alreadyAssigned.push(e);
4921-                        }
--
4952-                        });
4953-                        
4954-                        const existingEventIds = new Set(events.map(e => e.id));
4955-                        const otherEvents = currentScheduleForDate.filter(e => !existingEventIds.has(e.id));
4956-                        
4957:                        console.log(`ðŸŸ¢ Filtered out ${currentScheduleForDate.length - otherEvents.length} existing events`);
4958-                        
4959-                        newSchedules[eventDate] = [...otherEvents, ...events] as ScheduleEvent[];
4960-                        
4961-                        console.log(`ðŸŸ¢ Saved ${events.length} events to date ${eventDate}`);
4962-                        console.log(`ðŸŸ¢ New total for ${eventDate}:`, newSchedules[eventDate].length);
4963-                        
4964-                        // Log the specific event we just saved
4965-                        const savedEvent = newSchedules[eventDate].find(e => e.id === events[0].id);
4966-                        console.log(`ðŸŸ¢ Saved event details:`, {
4967-                            id: savedEvent?.id,
--
5135-        // Save cancellation record
5136-        const updatedRecords = [...cancellationRecords, cancellationRecord];
5137-        setCancellationRecords(updatedRecords);
5138-        localStorage.setItem('cancellationRecords', JSON.stringify(updatedRecords));
5139-        
5140:        // Mark event as cancelled (leave in original position, just add red X)
5141-        const cancelledEvent: ScheduleEvent = {
5142-            ...selectedEvent,
5143-            isCancelled: true,
5144-            cancellationCode: cancellationCode,
5145-            cancellationManualEntry: manualCodeEntry,
5146-            cancelledBy: `${currentUser}`,
5147-            cancelledAt: new Date().toISOString(),
5148-            // Keep original resourceId - don't move to STBY
5149-        };
5150-        
--
5317-                    pilot: sctReq.name, // Pilot field shows the person
5318-                    flightNumber: sctReq.event,
5319-                    duration: duration,
5320-                    startTime: startTime, // Use requested time
5321-                    resourceId: '', // Will be assigned during scheduling
5322:                    color: 'bg-red-500/50', // Highlight as high priority SCT
5323-                    flightType: sctReq.flightType,
5324-                    soloOrDual: sctReq.flightType,
5325-                    locationType: 'Local',
5326-                    origin: school,
5327-                    destination: school,
5328-                    isTimeFixed: true,
5329-                    isSct: true,
5330-                    eventCategory: 'sct', // This is the key field that makes it use SCT logic
5331-                    currency: sctReq.currency
5332-                };
--
5394-                    pilot: sctReq.name, // Pilot field shows the person
5395-                    flightNumber: sctReq.event,
5396-                    duration: duration,
5397-                    startTime: startTime, // Use requested time
5398-                    resourceId: '', // Will be assigned during scheduling
5399:                    color: 'bg-red-500/50', // Highlight as high priority SCT
5400-                    flightType: 'Dual',
5401-                    soloOrDual: 'Dual',
5402-                    locationType: 'Local',
5403-                    origin: school,
5404-                    destination: school,
5405-                    isTimeFixed: true,
5406-                    isSct: true,
5407-                    eventCategory: 'sct', // This is the key field that makes it use SCT logic
5408-                    currency: sctReq.currency
5409-                };
--
5463-                    if (!trainee) {
5464-                        console.error(`âŒ Trainee not found for ID: ${remedialReq.traineeId}`);
5465-                    }
5466-                    
5467-                    if (trainee && syllabusItem) {
5468:                        // CRITICAL FIX: Get allocated instructor from remedial package
5469-                        const allocatedInstructor = syllabusItem.resourcesHuman && syllabusItem.resourcesHuman.length > 0 
5470-                            ? syllabusItem.resourcesHuman[0] 
5471-                            : '';
5472-                        
5473-                        console.log(`ðŸ“‹ Allocated instructor for ${syllabusItem.code}: ${allocatedInstructor || 'None'}`);
5474-                        
5475-                        const newEvent: ScheduleEvent = {
5476-                            id: `remedial-${remedialReq.traineeId}-${remedialReq.eventCode}`,
5477-                            date: buildDfpDate,
5478-                            type: syllabusItem.type === 'FTD' ? 'ftd' : 
--
5885-            programWithPrimaries,
5886-            traineeLMPs,
5887-            flightTurnaround,
5888-            ftdTurnaround,
5889-            cptTurnaround,
5890:            preferredDutyPeriod,
5891-            maxCrewDutyPeriod,
5892-            eventLimits,
5893-            sctFtds: sctFtds,
5894-            sctFlights: sctFlights,
5895-            remedialRequests: remedialRequests,
5896-            sctEvents: sctEvents,
5897-            getEventDayNightClassification: getEventDayNightClassification,
5898-        };
5899-
5900-        setTimeout(() => {
--
6144-        return syllabusDetails.map(item => item.id);
6145-    }, [syllabusDetails]);
6146-
6147-    const addTileSyllabusOptions = useMemo(() => {
6148-        console.log('addTileSyllabusOptions filtering syllabusDetails:', syllabusDetails);
6149:        const filtered = syllabusDetails.filter(item => 
6150-            item.type === 'Flight' || 
6151-            item.type === 'FTD' ||
6152-            (item.type === 'Ground School' && item.code.includes('CPT'))
6153-        );
6154:        console.log('Filtered items:', filtered);
6155:        const options = filtered.map(item => item.id);
6156-        
6157-        // Add SCT FORM option if not already present
6158-        if (!options.includes('SCT FORM')) {
6159-            options.push('SCT FORM');
6160-        }
6161-        
6162-        return options;
6163-    }, [syllabusDetails]);
6164-    
6165-    const handleAuthorise = (eventId: string, notes: string, role: 'autho' | 'captain', isVerbal: boolean, selectedPersonName: string) => {
--
6725-            return;
6726-        }
6727-
6728-        console.log('ðŸ”§ Remedy type:', remedy.type);
6729-        console.log('ðŸ”§ Instructor duty hours:', remedy.type !== 'trainee' ? remedy.instructor.dutyHours : 'N/A');
6730:        console.log('ðŸ”§ Preferred duty period:', preferredDutyPeriod);
6731-
6732:        if (remedy.type !== 'trainee' && remedy.instructor.dutyHours > preferredDutyPeriod) {
6733:            console.log('âš ï¸ Duty warning triggered');
6734-            setDutyWarningRemedy(remedy);
6735-            setShowDutyWarning(true);
6736-        } else {
6737-            console.log('âœ… Executing remedy directly');
6738-            executeNeoRemedy(remedy, neoProblemTileForFlyout.event);
6739-        }
6740-    };
6741-
6742-    const handleConfirmDutyWarning = () => {
6743-        if (dutyWarningRemedy && neoProblemTileForFlyout) {
--
6809-                        else if (event.type === 'ftd') turnaround = ftdTurnaround;
6810-                        else if (event.type === 'cpt' || (event.type === 'ground' && event.flightNumber.includes('CPT'))) turnaround = cptTurnaround;
6811-                        
6812-                        if (event.startTime > conflictingEvent.startTime) {
6813-                            const gap = event.startTime - (conflictingEvent.startTime + conflictingEvent.duration);
6814:                            errors.push(`âŒ Turnaround violation - Only ${gap.toFixed(2)}hrs between ${event.flightNumber} and previous event ${conflictingEvent.flightNumber} (minimum required: ${turnaround}hrs)`);
6815-                        } else {
6816-                            const gap = conflictingEvent.startTime - (event.startTime + event.duration);
6817:                            errors.push(`âŒ Turnaround violation - Only ${gap.toFixed(2)}hrs between ${event.flightNumber} and next event ${conflictingEvent.flightNumber} (minimum required: ${turnaround}hrs)`);
6818-                        }
6819-                    }
6820-                    break;
6821-                    
6822-                case 'resource':
6823-                    if (conflictingEvent) {
6824-                        errors.push(`âŒ Resource conflict - Aircraft ${event.resourceId} is double-booked with ${conflictingEvent.flightNumber} at ${conflictingEvent.startTime.toFixed(2)}hrs`);
6825-                    }
6826-                    break;
6827-                    
--
6839-                    }
6840-                    break;
6841-            }
6842-        }
6843-
6844:        // ADDITIONAL CHECKS not covered by detectConflictsForEvent
6845-        
6846-        // Check for missing instructor on Dual events
6847-        if (event.flightType === 'Dual' && (!event.instructor || event.instructor.trim() === '' || event.instructor === 'TBD')) {
6848-            errors.push('âŒ No instructor assigned - Dual flights require an instructor.');
6849-        }
6850-
6851-        // Check for static unavailability for all personnel
6852-        const eventWindow = getEventBookingWindow(event, syllabusDetails);
6853-        const personnel = getPersonnel(event);
6854-        const allPersonnelData = [...instructorsData, ...traineesData];
--
6963-                
6964-                // Apply Solo logic: if Solo, set trainee as PIC and clear crew
6965-                if (individualLMPFlightType === 'Solo' && traineeName) {
6966-                    updatedEvent.pilot = traineeName;
6967-                    updatedEvent.crew = '';
6968:                    console.log(`âœˆï¸ [NEO Solo Logic] Applied: ${traineeName} as PIC, crew cleared for ${updatedEvent.flightNumber}`);
6969-                }
6970-                
6971-            }
6972-        }
6973-        
6974-        if (remedy.type === 'instructor') {
6975-            if (isSctEvent) {
6976-                // For SCT events, change the pilot (PIC) instead of instructor
6977-                console.log('ðŸŸ£ NEO: Applying pilot change for SCT event:', eventToUpdate.pilot, 'â†’', remedy.instructor.name);
6978-                updatedEvent.pilot = remedy.instructor.name;
--
7047-        // Find the LATEST version of the problem tile from the current state.
7048-        const updatedProblemTile = currentEvents.find(e => e.id === neoProblemTileForFlyout.event.id);
7049-
7050-        if (!updatedProblemTile) {
7051-            console.log('ðŸŸ  âŒ Event not found in current state, closing flyout');
7052:            // The event was deleted or somehow disappeared. Clean up and close.
7053-            setNeoProblemTileForFlyout(null);
7054-            setNeoRemediesForFlyout([]);
7055-            console.log('ðŸŸ  ========== NEO USEEFFECT END (NOT FOUND) ==========');
7056-            return;
7057-        }
7058-
7059-        console.log('ðŸŸ  Found updated problem tile:', {
7060-            id: updatedProblemTile.id,
7061-            instructor: updatedProblemTile.instructor,
7062-            student: updatedProblemTile.student,
--
7163-            const nextSyllabusEvent = computeNextEventsForTrainee(trainee, traineeLMPs, scores, syllabusDetails, publishedSchedules, buildDfpDate).next;
7164-            
7165-            // Enhanced eligibility logic for Oracle - proper trainee duty rules
7166-            let isEligible = nextSyllabusEvent?.type === 'Flight';
7167-            
7168:            // Rule 0: EXCLUDE PAUSED/NTSC TRAINEES - Oracle should NOT offer these trainees
7169-            if (trainee.isPaused) {
7170-                isEligible = false;
7171-                console.log(`Oracle: ${trainee.fullName} excluded - trainee is PAUSED`);
7172-            }
7173-            
7174-            // Check for NTSC status (assume it might be in course name or a status field)
7175-            const isNtsc = trainee.course.includes('NTSC') || trainee.fullName.includes('NTSC');
7176-            if (isNtsc) {
7177-                isEligible = false;
7178-                console.log(`Oracle: ${trainee.fullName} excluded - trainee is NTSC`);
7179-            }
7180-            
7181:            // Rule 1: EXCLUDE TRAINEES WHOSE NEXT EVENT IS REMEDIAL
7182-            if (nextSyllabusEvent && nextSyllabusEvent.isRemedial) {
7183-                isEligible = false;
7184-                console.log(`Oracle: ${trainee.fullName} excluded - next event ${nextSyllabusEvent.code} is REMEDIAL`);
7185-            }
7186-            
7187-            // Rule 2: Only one flight per day
7188-            if (hasFlight) {
7189-                isEligible = false;
7190-                console.log(`Oracle: ${trainee.fullName} ineligible - already has flight scheduled for ${analysisDate}`);
7191-            }
--
7322-        const availableTraineesAnalysis = oracleAnalysis.trainees.filter(tr => {
7323-            if (!tr.isEligible) return false;
7324-            
7325-            const personEvents = currentEvents.filter(e => getPersonnel(e).includes(tr.trainee.fullName));
7326-            
7327:            // CRITICAL FIX 1: Check if trainee already has a flight scheduled for this day (one flight per day rule)
7328-            const hasExistingFlightToday = personEvents.some(e => 
7329-                e.type === 'flight' && e.date === analysisDate
7330-            );
7331-            if (hasExistingFlightToday) {
7332-                console.log(`Oracle: Excluding ${tr.trainee.fullName} - already has a flight scheduled for ${analysisDate}`);
7333-                return false;
7334-            }
7335-            
7336:            // CRITICAL FIX 2: Check if trainee is already scheduled for this specific event
7337-            // We'll use the next syllabus event to determine what they would be scheduled for
7338-            if (tr.nextSyllabusEvent) {
7339-                const hasThisEventAlready = personEvents.some(e => 
7340-                    e.flightNumber === tr.nextSyllabusEvent.id && e.date === analysisDate
7341-                );
7342-                if (hasThisEventAlready) {
7343-                    console.log(`Oracle: Excluding ${tr.trainee.fullName} - already scheduled for event ${tr.nextSyllabusEvent.id} on ${analysisDate}`);
7344-                    return false;
7345-                }
7346-            }
--
7578-                            onSelectTrainee={handleSelectTraineeFromSchedule}
7579-                            courseColors={courseColors}
7580-                       />;
7581-            case 'InstructorSchedule':
7582-                // DEBUG: Log all data being passed to InstructorScheduleView
7583:                console.log('ðŸ” STAFF SCHEDULE DEBUG - Case triggered');
7584-                console.log('ðŸ” date:', date);
7585-                console.log('ðŸ” handleDateChange:', typeof handleDateChange);
7586-                console.log('ðŸ” eventSegmentsForDate count:', eventSegmentsForDate?.length);
7587-                console.log('ðŸ” instructorsData count:', instructorsData?.length);
7588-                console.log('ðŸ” traineesData count:', traineesData?.length);
7589-                console.log('ðŸ” handleOpenModal:', typeof handleOpenModal);
7590-                console.log('ðŸ” handleScheduleUpdate:', typeof handleScheduleUpdate);
7591-                console.log('ðŸ” zoomLevel:', zoomLevel);
7592-                console.log('ðŸ” daylightTimes:', { firstLight: '06:30', lastLight: '18:30' });
7593-                console.log('ðŸ” personnelData size:', personnelData?.size);
--
7737-                            }}
7738-                        />;
7739-            case 'HateSheet':
7740-                if (selectedTraineeForHateSheet) {
7741-                    const traineeAssessments = Array.from(pt051Assessments.values()).filter(
7742:                        // FIX: Add explicit type annotation for `a` as TypeScript was failing to infer it.
7743-                        (a: Pt051Assessment) => a.traineeFullName === selectedTraineeForHateSheet.fullName
7744-                    );
7745-                    const eventFromSchedules = [...eventsForDate, ...highestPriorityEvents];
7746-                    return <HateSheetView
7747-                                trainee={selectedTraineeForHateSheet}
7748-                                lmpScores={scores.get(selectedTraineeForHateSheet.fullName) || []}
7749-                                assessments={traineeAssessments}
7750-                                pt051Events={traineeAssessments}
7751-                                userProfile={currentUser}
7752-                                refreshEvents={() => {
--
7761-                                    console.log('onSelectPt051 called with assessment:', assessment);
7762-                                    
7763-                                    // Log PT-051 view to audit trail
7764-                                    logAudit('Performance History', 'View', `Viewed PT-051 for ${assessment.traineeFullName} - Event: ${assessment.flightNumber} (${assessment.date})`);
7765-                                    
7766:                                    // FIX: Add explicit type annotation for `a` as TypeScript was failing to infer it.
7767-                                    const event = eventFromSchedules.find((a: ScheduleEvent) => a.id === assessment.eventId);
7768-                                    if(event) {
7769-                                        console.log('Found event in schedules:', event);
7770-                                        setEventForPt051(event);
7771-                                        handleNavigation('PT051');
7772-                                    } else {
7773-                                        const eventFromBuild = nextDayBuildEvents.find(e => e.id === assessment.eventId);
7774-                                        if (eventFromBuild) {
7775-                                            console.log('Found event in build:', eventFromBuild);
7776-                                            setEventForPt051({ ...eventFromBuild, date: buildDfpDate });
--
8042-                            
8043-                            // Trigger priority sync after a short delay to ensure state is updated
8044-                            setTimeout(() => {
8045-                                // Force a sync with the latest state by triggering the useEffect
8046-                                // The useEffect will catch the updated remedialRequests state
8047:                                console.log('ðŸ”„ Manual sync triggered from setTimeout');
8048-                                syncPriorityEventsWithSctAndRemedial();
8049-                            }, 100);
8050-                            
8051-                            return newRequests;
8052-                        });
8053-                    }}
8054-                    currencyNames={currencyNames}
8055-                />;
8056-            case 'CourseProgress':
8057-                return <CourseProgressView
--
8441-                    syllabusDetails={syllabusDetails}
8442-                    onBulkUpdateInstructors={handleBulkUpdateInstructors}
8443-                    onReplaceInstructors={handleReplaceInstructors}
8444-                    onBulkUpdateTrainees={handleBulkUpdateTrainees}
8445-                    onReplaceTrainees={handleReplaceTrainees}
8446:                    // FIX: Cannot find name 'onUpdateSyllabus'. Did you mean 'handleUpdateSyllabus'?
8447-                    onUpdateSyllabus={handleUpdateSyllabus}
8448-                    onShowSuccess={setSuccessMessage}
8449-                    eventLimits={eventLimits}
8450-                    onUpdateEventLimits={setEventLimits}
8451-                    phraseBank={phraseBank} // Pass phraseBank state
8452-                    onUpdatePhraseBank={setPhraseBank} // Pass update handler
8453-                    onNavigate={handleNavigation}
8454-                    masterCurrencies={masterCurrencies}
8455-                    currencyRequirements={currencyRequirements}
8456-                    sctEvents={sctEvents}
8457-                    onUpdateSctEvents={setSctEvents}
8458:                    preferredDutyPeriod={preferredDutyPeriod}
8459:                    onUpdatePreferredDutyPeriod={setPreferredDutyPeriod}
8460-                    maxCrewDutyPeriod={maxCrewDutyPeriod}
8461-                    onUpdateMaxCrewDutyPeriod={setMaxCrewDutyPeriod}
8462-                    flightTurnaround={flightTurnaround}
8463-                    onUpdateFlightTurnaround={setFlightTurnaround}
8464-                    ftdTurnaround={ftdTurnaround}
8465-                    onUpdateFtdTurnaround={setFtdTurnaround}
8466-                    cptTurnaround={cptTurnaround}
8467-                    onUpdateCptTurnaround={setCptTurnaround}
8468-                    currentUserPermission={currentUserPermission}
8469-                    maxDispatchPerHour={maxDispatchPerHour}
--
8592-                    eventForPt051,
8593-                    selectedTraineeForHateSheet,
8594-                    view
8595-                });
8596-                return <div className="p-8 bg-gray-900 text-white">
8597:                    <h2 className="text-2xl font-bold text-red-500 mb-4">Error: PT-051 View Context Missing</h2>
8598-                    <p className="mb-2">Trainee: {selectedTraineeForHateSheet ? 'âœ… Set' : 'âŒ Not Set'}</p>
8599-                    <p className="mb-2">Event: {eventForPt051 ? 'âœ… Set' : 'âŒ Not Set'}</p>
8600-                    <button 
8601-                        onClick={() => handleNavigation('MyDashboard')}
8602-                        className="mt-4 px-4 py-2 bg-sky-600 text-white rounded-md hover:bg-sky-700"
8603-                    >
8604-                        Back to Dashboard
8605-                    </button>
8606-                </div>;
8607-            case 'PostFlight':
--
8873-            )}
8874-            {showDutyWarning && dutyWarningRemedy && (
8875-                <DutyWarningFlyout
8876-                    onConfirm={handleConfirmDutyWarning}
8877-                    onCancel={() => setShowDutyWarning(false)}
8878:                    // FIX: Replaced 'remedy' with 'dutyWarningRemedy' to access component props from the correct state variable.
8879-                    instructorName={dutyWarningRemedy.type !== 'trainee' ? dutyWarningRemedy.instructor.name : ''}
8880:                    // FIX: Replaced 'remedy' with 'dutyWarningRemedy' to access component props from the correct state variable.
8881-                    dutyHours={dutyWarningRemedy.type !== 'trainee' ? dutyWarningRemedy.instructor.dutyHours : 0}
8882-                />
8883-            )}
8884-            {showInfoNotification && <InfoNotification message={showInfoNotification} onClose={() => setShowInfoNotification(null)} />}
8885-            {showNightFlyingInfo && <NightFlyingInfoFlyout traineeCount={nightFlyingTraineeCount} />}
8886-            {isBuildingDfp && <BuildDfpLoadingFlyout progress={dfpBuildProgress} />}
8887-            {showDateWarning && <BuildDateWarningFlyout onConfirm={handleConfirmDateAndBuild} onCancel={() => setShowDateWarning(false)} date={buildDfpDate} />}
8888-            {unavailabilityNotifications.length > 0 && <UnavailabilityConflictFlyout notifications={unavailabilityNotifications} onDismiss={() => setUnavailabilityNotifications([])} />}
8889-            {showPublishConfirm && <PublishConfirmationFlyout date={buildDfpDate} onConfirm={handleConfirmPublish} onCancel={() => setShowPublishConfirm(false)} />}
8890-            {isLocalityChangeVisible && <LocalityChangeFlyout locality={school} />}
