    const handleCancelEvent = (eventId: string, cancellationCode: string, manualCodeEntry?: string) => {
        if (!selectedEvent) return;
        const eventDate = selectedEvent.date;
        
        // Create cancellation record
        const cancellationRecord: CancellationRecord = {
            eventId: selectedEvent.id,
            cancellationCode: cancellationCode,
            cancelledBy: `${currentUser}`,
            cancelledAt: new Date().toISOString(),
            manualCodeEntry: manualCodeEntry,
            eventDate: selectedEvent.date,
            eventType: selectedEvent.type === 'ftd' ? 'ftd' : 'flight',
            resourceType: selectedEvent.resourceId || 'Unknown',
        };
        
        // Save cancellation record
        const updatedRecords = [...cancellationRecords, cancellationRecord];
        setCancellationRecords(updatedRecords);
        localStorage.setItem('cancellationRecords', JSON.stringify(updatedRecords));
        
        // Mark event as cancelled and move to STBY
        const cancelledEvent: ScheduleEvent = {
            ...selectedEvent,
            isCancelled: true,
            cancellationCode: cancellationCode,
            cancellationManualEntry: manualCodeEntry,
            cancelledBy: `${currentUser}`,
            cancelledAt: new Date().toISOString(),
            resourceId: selectedEvent.type === 'ftd' ? 'BNF-STBY' : 'STBY',
        };
        
        const isNextDay = eventDate === buildDfpDate && (activeView === 'NextDayBuild' || activeView === 'Priorities' || activeView === 'ProgramData');
        
        if (isNextDay) {
            setNextDayBuildEvents(prev => prev.map(e => e.id === selectedEvent.id ? cancelledEvent : e));
        } else {
            setPublishedSchedules((prev: Record<string, ScheduleEvent[]>) => {
                const scheduleForDate = prev[eventDate] || [];
                const updatedSchedule = scheduleForDate.map(e => e.id === selectedEvent.id ? cancelledEvent : e);
                return { ...prev, [eventDate]: updatedSchedule };
            });
        }
        
        // Remove from highest priority events
        setHighestPriorityEvents(prev => prev.filter(e => e.id !== selectedEvent.id));
        
        // Log the cancellation to audit trail
        const pageName = isNextDay ? 'Next Day Build' : 'Program Schedule';
        const eventType = selectedEvent.type || 'event';
        const personName = selectedEvent.student || selectedEvent.pilot || selectedEvent.instructor || 'Unknown';
        const codeDisplay = cancellationCode === 'OTHER' && manualCodeEntry ? manualCodeEntry : cancellationCode;
        const description = `Cancelled ${eventType} event for ${personName} (Code: ${codeDisplay})`;
        const changes = `Event: ${selectedEvent.syllabusItem || selectedEvent.flightNumber || eventType}, Time: ${selectedEvent.startTime}, Duration: ${selectedEvent.duration}hrs, Moved to STBY`;
        
        logAudit(pageName, "Cancel", description, changes);
        setSelectedEvent(null);
    };
    
    const handleDeleteEvent = () => {
        if (!selectedEvent) return;
        const eventDate = selectedEvent.date;

        setHighestPriorityEvents(prev => prev.filter(e => e.id !== selectedEvent.id));

        const isNextDay = eventDate === buildDfpDate && (activeView === 'NextDayBuild' || activeView === 'Priorities' || activeView === 'ProgramData');

        if (isNextDay) {
            setNextDayBuildEvents(prev => prev.filter(e => e.id !== selectedEvent.id));
        } else {
            setPublishedSchedules((prev: Record<string, ScheduleEvent[]>) => {
                const newScheduleForDate = (prev[eventDate] || []).filter(e => e.id !== selectedEvent.id);
                return { ...prev, [eventDate]: newScheduleForDate };
