exports.id=1873,exports.ids=[1873],exports.modules={3421:(a,b,c)=>{"use strict";Object.defineProperty(b,"I",{enumerable:!0,get:function(){return g}});let d=c(71237),e=c(55088),f=c(17679);async function g(a,b,c,g){if((0,d.isNodeNextResponse)(b)){var h;b.statusCode=c.status,b.statusMessage=c.statusText;let d=["set-cookie","www-authenticate","proxy-authenticate","vary"];null==(h=c.headers)||h.forEach((a,c)=>{if("x-middleware-set-cookie"!==c.toLowerCase())if("set-cookie"===c.toLowerCase())for(let d of(0,f.splitCookiesString)(a))b.appendHeader(c,d);else{let e=void 0!==b.getHeader(c);(d.includes(c.toLowerCase())||!e)&&b.appendHeader(c,a)}});let{originalResponse:i}=b;c.body&&"HEAD"!==a.method?await (0,e.pipeToNodeResponse)(c.body,i,g):i.end()}}},13958:(a,b,c)=>{"use strict";c.d(b,{z:()=>e});var d=c(96330);let e=globalThis.prisma??new d.PrismaClient({datasources:{db:{url:process.env.DATABASE_URL||"postgresql://placeholder"}}});globalThis.backupPrisma??new d.PrismaClient({datasources:{db:{url:process.env.BACKUP_DATABASE_URL||process.env.DATABASE_URL||"postgresql://placeholder"}}})},78335:()=>{},93148:(a,b,c)=>{"use strict";c.d(b,{Kh:()=>G,Vg:()=>C,cC:()=>D,l4:()=>F,nr:()=>E});var d=c(73519),e=c(33164);function f(a,b){let c=`SHA-${a.slice(-3)}`;switch(a){case"HS256":case"HS384":case"HS512":return{hash:c,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:c,name:"RSA-PSS",saltLength:parseInt(a.slice(-3),10)>>3};case"RS256":case"RS384":case"RS512":return{hash:c,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:c,name:"ECDSA",namedCurve:b.namedCurve};case"Ed25519":case"EdDSA":return{name:"Ed25519"};case"ML-DSA-44":case"ML-DSA-65":case"ML-DSA-87":return{name:a};default:throw new e.T0(`alg ${a} is not supported either by JOSE or your javascript runtime`)}}var g=c(80193),h=c(27701),i=c(41330);async function j(a,b,c){if(b instanceof Uint8Array){if(!a.startsWith("HS"))throw TypeError((0,i.X)(b,"CryptoKey","KeyObject","JSON Web Key"));return crypto.subtle.importKey("raw",b,{hash:`SHA-${a.slice(-3)}`,name:"HMAC"},!1,[c])}return(0,h.Y)(b,a,c),b}async function k(a,b,c){let d=await j(a,b,"sign");return(0,g.O)(a,d),new Uint8Array(await crypto.subtle.sign(f(a,d.algorithm),d,c))}var l=c(66719),m=c(37432),n=c(80053),o=c(17969),p=c(80801);class q{#a;#b;#c;constructor(a){if(!(a instanceof Uint8Array))throw TypeError("payload must be an instance of Uint8Array");this.#a=a}setProtectedHeader(a){if(this.#b)throw TypeError("setProtectedHeader can only be called once");return this.#b=a,this}setUnprotectedHeader(a){if(this.#c)throw TypeError("setUnprotectedHeader can only be called once");return this.#c=a,this}async sign(a,b){let c,f,g,h;if(!this.#b&&!this.#c)throw new e.Ye("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!(0,l.f)(this.#b,this.#c))throw new e.Ye("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");let i={...this.#b,...this.#c},j=(0,o.n)(e.Ye,new Map([["b64",!0]]),b?.crit,this.#b,i),q=!0;if(j.has("b64")&&"boolean"!=typeof(q=this.#b.b64))throw new e.Ye('The "b64" (base64url-encode payload) Header Parameter must be a boolean');let{alg:r}=i;if("string"!=typeof r||!r)throw new e.Ye('JWS "alg" (Algorithm) Header Parameter missing or invalid');(0,n.y)(r,a,"sign"),q?(c=(0,d.l)(this.#a),f=(0,m.lF)(c)):(f=this.#a,c=""),this.#b?(g=(0,d.l)(JSON.stringify(this.#b)),h=(0,m.lF)(g)):(g="",h=new Uint8Array);let s=(0,m.xW)(h,(0,m.lF)("."),f),t=await (0,p.l)(a,r),u=await k(r,t,s),v={signature:(0,d.l)(u),payload:c};return this.#c&&(v.header=this.#c),this.#b&&(v.protected=g),v}}class r{#d;constructor(a){this.#d=new q(a)}setProtectedHeader(a){return this.#d.setProtectedHeader(a),this}async sign(a,b){let c=await this.#d.sign(a,b);if(void 0===c.payload)throw TypeError("use the flattened module for creating JWS with b64: false");return`${c.protected}.${c.payload}.${c.signature}`}}var s=c(7448);class t{#b;#e;constructor(a={}){this.#e=new s.cE(a)}setIssuer(a){return this.#e.iss=a,this}setSubject(a){return this.#e.sub=a,this}setAudience(a){return this.#e.aud=a,this}setJti(a){return this.#e.jti=a,this}setNotBefore(a){return this.#e.nbf=a,this}setExpirationTime(a){return this.#e.exp=a,this}setIssuedAt(a){return this.#e.iat=a,this}setProtectedHeader(a){return this.#b=a,this}async sign(a,b){let c=new r(this.#e.data());if(c.setProtectedHeader(this.#b),Array.isArray(this.#b?.crit)&&this.#b.crit.includes("b64")&&!1===this.#b.b64)throw new e.Dp("JWTs MUST NOT use unencoded payload");return c.sign(a,b)}}async function u(a,b,c,d){let e=await j(a,b,"verify");(0,g.O)(a,e);let h=f(a,e.algorithm);try{return await crypto.subtle.verify(h,e,c,d)}catch{return!1}}var v=c(32712),w=c(1911);async function x(a,b,c){let f,g;if(!(0,v.G)(a))throw new e.Ye("Flattened JWS must be an object");if(void 0===a.protected&&void 0===a.header)throw new e.Ye('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==a.protected&&"string"!=typeof a.protected)throw new e.Ye("JWS Protected Header incorrect type");if(void 0===a.payload)throw new e.Ye("JWS Payload missing");if("string"!=typeof a.signature)throw new e.Ye("JWS Signature missing or incorrect type");if(void 0!==a.header&&!(0,v.G)(a.header))throw new e.Ye("JWS Unprotected Header incorrect type");let h={};if(a.protected)try{let b=(0,d.D)(a.protected);h=JSON.parse(m.D0.decode(b))}catch{throw new e.Ye("JWS Protected Header is invalid")}if(!(0,l.f)(h,a.header))throw new e.Ye("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");let i={...h,...a.header},j=(0,o.n)(e.Ye,new Map([["b64",!0]]),c?.crit,h,i),k=!0;if(j.has("b64")&&"boolean"!=typeof(k=h.b64))throw new e.Ye('The "b64" (base64url-encode payload) Header Parameter must be a boolean');let{alg:q}=i;if("string"!=typeof q||!q)throw new e.Ye('JWS "alg" (Algorithm) Header Parameter missing or invalid');let r=c&&(0,w.F)("algorithms",c.algorithms);if(r&&!r.has(q))throw new e.Rb('"alg" (Algorithm) Header Parameter value not allowed');if(k){if("string"!=typeof a.payload)throw new e.Ye("JWS Payload must be a string")}else if("string"!=typeof a.payload&&!(a.payload instanceof Uint8Array))throw new e.Ye("JWS Payload must be a string or an Uint8Array instance");let s=!1;"function"==typeof b&&(b=await b(h,a),s=!0),(0,n.y)(q,b,"verify");let t=(0,m.xW)(void 0!==a.protected?(0,m.lF)(a.protected):new Uint8Array,(0,m.lF)("."),"string"==typeof a.payload?k?(0,m.lF)(a.payload):m.Rd.encode(a.payload):a.payload);try{f=(0,d.D)(a.signature)}catch{throw new e.Ye("Failed to base64url decode the signature")}let x=await (0,p.l)(b,q);if(!await u(q,x,f,t))throw new e.h2;if(k)try{g=(0,d.D)(a.payload)}catch{throw new e.Ye("Failed to base64url decode the payload")}else g="string"==typeof a.payload?m.Rd.encode(a.payload):a.payload;let y={payload:g};return(void 0!==a.protected&&(y.protectedHeader=h),void 0!==a.header&&(y.unprotectedHeader=a.header),s)?{...y,key:x}:y}async function y(a,b,c){if(a instanceof Uint8Array&&(a=m.D0.decode(a)),"string"!=typeof a)throw new e.Ye("Compact JWS must be a string or Uint8Array");let{0:d,1:f,2:g,length:h}=a.split(".");if(3!==h)throw new e.Ye("Invalid Compact JWS");let i=await x({payload:f,protected:d,signature:g},b,c),j={payload:i.payload,protectedHeader:i.protectedHeader};return"function"==typeof b?{...j,key:i.key}:j}async function z(a,b,c){let d=await y(a,b,c);if(d.protectedHeader.crit?.includes("b64")&&!1===d.protectedHeader.b64)throw new e.Dp("JWTs MUST NOT use unencoded payload");let f={payload:(0,s.k6)(d.protectedHeader,d.payload,c),protectedHeader:d.protectedHeader};return"function"==typeof b?{...f,key:d.key}:f}var A=c(13958);let B=new TextEncoder().encode(process.env.NEXTAUTH_SECRET||"your-secret-key-change-in-production");async function C(a){return await new t({userId:a,type:"access"}).setProtectedHeader({alg:"HS256"}).setIssuedAt().setExpirationTime("1h").sign(B)}async function D(a){return await new t({userId:a,type:"refresh"}).setProtectedHeader({alg:"HS256"}).setIssuedAt().setExpirationTime("30d").sign(B)}async function E(a){try{let{payload:b}=await z(a,B);if("string"==typeof b.userId&&("access"===b.type||"refresh"===b.type))return b;return null}catch(a){return console.error("Token verification failed:",a),null}}async function F(a){let b=await E(a);return b&&"access"===b.type?await A.z.user.findUnique({where:{id:b.userId}}):null}function G(a){let b=`${a.firstName||""} ${a.lastName||""}`.trim()||a.userId;return{id:a.id,userId:a.userId,displayName:b,email:a.email,isActive:a.isActive,role:a.role}}},95736:(a,b,c)=>{"use strict";a.exports=c(44870)},96487:()=>{}};