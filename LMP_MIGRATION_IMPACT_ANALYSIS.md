# LMP Migration Impact Analysis - DETAILED REPORT

## Executive Summary

**CRITICAL FINDING: LMPs are HARDCODED in TypeScript. Migrating to Prisma WILL break the NEO build algorithm unless code changes are made.**

This report provides a comprehensive analysis of how Lesson Management Plans (LMPs) are currently implemented and the impact of migrating them to the Prisma database.

---

## Section 1: Current LMP Implementation

### 1.1 Data Source Location

**LMPs are completely hardcoded in TypeScript files:**

**File:** `mockData.ts`
- **Location:** Lines 130-280 (approximately)
- **Variable:** `syllabusItems: SyllabusItemDetail[]`
- **Export:** `INITIAL_SYLLABUS_DETAILS`

**Example of Hardcoded LMP Data:**
```typescript
const syllabusItems: SyllabusItemDetail[] = [
    // BPC + IPC Items
    createSyllabusItem('BGF MB1', 'Preparation and Pre / Post Flight Admin'),
    createSyllabusItem('BGF MB2', 'Ground Operations and Checklist'),
    createSyllabusItem('BGF1', 'Effects of Controls; Attitude Flying; Straight and Level; Turning; Steep Turn'),
    createSyllabusItem('BGF2', 'Basic AP Operation; Climbing; Descending; Climbing, Turning and Descending; Re-join; Landing'),
    // ... 100+ more hardcoded events
];
```

### 1.2 LMP Data Structure

**Type Definition:** `types.ts`

```typescript
export interface SyllabusItemDetail {
  id: string;
  code: string;
  phase: string;
  module: string;
  dayNight: 'Day' | 'Night' | 'Day/Night';
  eventDescription: string;
  prerequisites: string[];
  prerequisitesGround: string[];
  prerequisitesFlying: string[];
  eventDetailsCommon: string[];
  eventDetailsSortie: string[];
  totalEventHours: number;
  flightOrSimHours: number;
  duration: number;
  preFlightTime: number;
  postFlightTime: number;
  type: 'Flight' | 'FTD' | 'Ground School';
  sortieType?: 'Dual' | 'Solo';
  twrDiReqd?: 'YES' | 'NO';
  cctOnly?: 'YES' | 'NO';
  methodOfDelivery: string[];
  methodOfAssessment: string[];
  resourcesPhysical: string[];
  resourcesHuman: string[];
  isRemedial?: boolean;
  location: string;
  courses: string[]; // Used for filtering by course
  lmpType?: 'Master LMP' | 'Staff CAT'; // Used for filtering by type
}
```

### 1.3 How LMPs Are Loaded

**File:** `mockData.ts` (Lines 1203-1204)

```typescript
const traineeLMPs = new Map<string, SyllabusItemDetail[]>();
allocatedTrainees.forEach(t => traineeLMPs.set(t.fullName, INITIAL_SYLLABUS_DETAILS));
```

**Key Points:**
1. LMP data is generated at application startup
2. Every trainee gets assigned the same master syllabus (`INITIAL_SYLLABUS_DETAILS`)
3. Individual LMPs (remedial, custom) are stored in a Map keyed by trainee name
4. Data is stored in memory as a TypeScript Map

### 1.4 App State Initialization

**File:** `App.tsx` (Line 3107)

```typescript
const [traineeLMPs, setTraineeLMPs] = useState<Map<string, SyllabusItemDetail[]>>(ESL_DATA.traineeLMPs);
```

- LMP data is loaded from `ESL_DATA` (generated by `mockData.ts`)
- Stored as React state
- No database queries are made for LMP data

---

## Section 2: NEO Build Algorithm Dependency

### 2.1 Core Function: `computeNextEventsForTrainee`

**File:** `App.tsx` (Lines 516-580)

```typescript
const computeNextEventsForTrainee = (
    trainee: Trainee,
    traineeLMPs: Map<string, SyllabusItemDetail[]>,
    scores: Map<string, Score[]>,
    masterSyllabus: SyllabusItemDetail[],
    publishedSchedules?: Record<string, ScheduleEvent[]>,
    buildDate?: string
): { next: SyllabusItemDetail | null, plusOne: SyllabusItemDetail | null } => {
    // Check individual LMP first, then fallback to master syllabus
    const hasIndividualLMP = traineeLMPs.has(trainee.fullName);
    const individualLMP = traineeLMPs.get(trainee.fullName) || masterSyllabus;
    
    if (!individualLMP || individualLMP.length === 0) {
        return { next: null, plusOne: null };
    }
    
    const traineeScores = scores.get(trainee.fullName) || [];
    const completedEventIds = new Set(traineeScores.map(s => s.event));
    
    // NEW: Check for ELCE - events completed yesterday but not yet in PT-051
    if (publishedSchedules && buildDate) {
        const elce = getEffectiveLastCompletedEvent(trainee.fullName, publishedSchedules, buildDate);
        if (elce) {
            completedEventIds.add(elce);
        }
    }

    let nextEvt: SyllabusItemDetail | null = null;
    let plusOneEvt: SyllabusItemDetail | null = null;
    let nextEventIndex = -1;

    // Find Next Event
    for (let i = 0; i < individualLMP.length; i++) {
        const item = individualLMP[i];
        if (completedEventIds.has(item.id) || item.code.includes(' MB')) {
            continue;
        }

        const prereqsMet = item.prerequisites.every(p => completedEventIds.has(p));
        if (prereqsMet) {
            nextEvt = item;
            nextEventIndex = i;
            break;
        }
    }
    
    // Find Next +1 Event (sequentially)
    if (nextEventIndex !== -1) {
        for (let i = nextEventIndex + 1; i < individualLMP.length; i++) {
            const item = individualLMP[i];
            if (!item.code.includes(' MB')) {
                plusOneEvt = item;
                break;
            }
        }
    }

    return { next: nextEvt, plusOne: plusOneEvt };
};
```

### 2.2 NEO Build Function: `generateDfpInternal`

**File:** `App.tsx` (Line 960)

```typescript
function generateDfpInternal(
    config: DfpConfig, 
    setProgress: (progress: { message: string, percentage: number }) => void,
    publishedSchedules: Record<string, ScheduleEvent[]>
): Omit<ScheduleEvent, 'date'>[] {
    // ... configuration setup ...
    
    // Uses traineeLMPs directly from memory
    activeTrainees.forEach(trainee => {
        const nextEvents = computeNextEventsForTrainee(
            trainee, 
            traineeLMPs, 
            scores, 
            syllabusDetails,
            publishedSchedules,
            buildDate
        );
        traineeNextEventMap.set(trainee.fullName, nextEvents);
    });
    
    // ... rest of algorithm ...
}
```

### 2.3 Critical Dependencies

**The NEO build algorithm depends on:**

1. **`traineeLMPs`** - A Map of trainee name to syllabus items (in memory)
2. **`syllabusDetails`** - The master syllabus array (in memory)
3. **`scores`** - Trainee completion records (from PT-051 assessments)
4. **`computeNextEventsForTrainee`** - Function that determines what event comes next

**All of these are currently loaded from HARDCODED data in `mockData.ts`**

---

## Section 3: Database Schema Analysis

### 3.1 Current Prisma Schema

**File:** `dfp-neo-platform/prisma/schema.prisma`

**Existing Models:**
- ✅ User
- ✅ Session
- ✅ Schedule
- ✅ UserSettings
- ✅ DataBackup
- ✅ FlightSchedule
- ✅ Personnel
- ✅ Aircraft
- ✅ CancellationHistory
- ✅ AuditLog

**MISSING Models (NOT in schema):**
- ❌ LMP (Lesson Management Plan)
- ❌ SyllabusItem
- ❌ Course
- ❌ Prerequisite

### 3.2 What IS in the Database

The database currently stores:
- **User accounts** (authentication, roles)
- **Schedule data** (as JSON blobs in `Schedule.data` and `FlightSchedule.scheduleData`)
- **Personnel records** (instructors, trainees with basic info)
- **Aircraft information**
- **Cancellation history**
- **Audit logs**

**LMP data is NOT in the database.**

---

## Section 4: Data Flow Analysis

### 4.1 Current Data Flow (No Database)

```
mockData.ts (HARDCODED)
    ↓
INITIAL_SYLLABUS_DETAILS (Array of 100+ items)
    ↓
generateDataSet() function
    ↓
traineeLMPs Map (traineeName → syllabus items)
    ↓
ESL_DATA.traineeLMPs
    ↓
App.tsx useState initialization
    ↓
computeNextEventsForTrainee() (NEO build algorithm)
    ↓
Generate DFP schedule
```

### 4.2 Required Data Flow (With Database)

```
Database (PostgreSQL via Prisma)
    ↓
Prisma Client Query
    ↓
API Route (e.g., /api/lmp)
    ↓
Frontend fetch()
    ↓
traineeLMPs Map
    ↓
computeNextEventsForTrainee() (NEO build algorithm)
    ↓
Generate DFP schedule
```

---

## Section 5: Impact Assessment

### 5.1 What CAN be Migrated (No Code Changes Needed)

**Data that can be moved to Prisma:**
1. ✅ **User accounts** - Already in database
2. ✅ **Schedule data** - Already in database
3. ✅ **Personnel records** - Already in database
4. ✅ **Aircraft information** - Already in database

**Migrating these requires NO changes to NEO build algorithm.**

### 5.2 What CANNOT be Migrated (Code Changes Required)

**LMPs (Lesson Management Plans):**

**Current Implementation:**
- Hardcoded in `mockData.ts`
- 100+ syllabus items with complex relationships
- Prerequisite chains
- Course associations
- Duration, timing, resource requirements

**Why Migrating to Prisma Will Break NEO:**

1. **`computeNextEventsForTrainee` expects in-memory data:**
   ```typescript
   const individualLMP = traineeLMPs.get(trainee.fullName) || masterSyllabus;
   ```
   - This reads from a Map in memory
   - Cannot directly query database from this function

2. **`generateDfpInternal` passes `traineeLMPs` as parameter:**
   ```typescript
   const nextEvents = computeNextEventsForTrainee(
       trainee, 
       traineeLMPs,  // ← This is an in-memory Map
       scores, 
       syllabusDetails,  // ← This is an in-memory Array
       publishedSchedules,
       buildDate
   );
   ```

3. **`syllabusDetails` is also hardcoded:**
   - Used throughout the application
   - No database query mechanism exists

### 5.3 Required Code Changes for LMP Migration

To migrate LMPs to Prisma, the following MUST be changed:

#### Option A: Load LMPs at Startup (Minimum Changes)

**Changes Required:**
1. Create API route to fetch LMP data from database
2. Fetch LMP data in `App.tsx` `useEffect` on mount
3. Store in `traineeLMPs` state (same as current)
4. Update loading state to wait for LMP fetch

**Example:**
```typescript
// New API route: app/api/lmp/route.ts
import { prisma } from '@/lib/db/prisma';

export async function GET() {
  const lmps = await prisma.syllabusItem.findMany();
  return Response.json(lmps);
}

// Updated App.tsx
useEffect(() => {
  async function loadLMPs() {
    const response = await fetch('/api/lmp');
    const data = await response.json();
    const lmpMap = new Map<string, SyllabusItemDetail[]>();
    // Convert database records to SyllabusItemDetail format
    data.forEach(item => {
      // Map database fields to TypeScript interface
      const syllabusItem: SyllabusItemDetail = {
        id: item.id,
        code: item.code,
        // ... map all fields
      };
      // Add to map
    });
    setTraineeLMPs(lmpMap);
  }
  loadLMPs();
}, []);
```

**Pros:**
- Minimal changes to NEO algorithm
- Maintains current data structure
- Performance is good (load once at startup)

**Cons:**
- Still no real-time updates
- Need to restart app to see LMP changes
- Schema migration still required

#### Option B: Query Database on Demand (Major Changes)

**Changes Required:**
1. Refactor `computeNextEventsForTrainee` to be async
2. Add database queries inside the function
3. Update all callers to handle async operations
4. Add error handling for database failures
5. Update all 20+ call sites throughout App.tsx

**Example:**
```typescript
const computeNextEventsForTrainee = async (  // ← NOW ASYNC
    trainee: Trainee,
    traineeLMPs: Map<string, SyllabusItemDetail[]>,  // ← May no longer need this
    scores: Map<string, Score[]>,
    masterSyllabus: SyllabusItemDetail[]  // ← May no longer need this
): Promise<{ next: SyllabusItemDetail | null, plusOne: SyllabusItemDetail | null }> => {
    // Query database for this trainee's LMP
    const individualLMP = await prisma.syllabusItem.findMany({
        where: {
            traineeName: trainee.fullName
        },
        orderBy: {
            sequence: 'asc'
        }
    });
    
    // ... rest of logic
};
```

**Pros:**
- Real-time LMP updates
- Always uses latest data

**Cons:**
- **MAJOR code changes required**
- Performance impact (many database queries during build)
- Complex error handling
- Higher risk of breaking existing functionality

---

## Section 6: Course Data Analysis

### 6.1 Current Course Data

**Location:** `mockData.ts` (Lines 1189-1198)

```typescript
const eslCourses: Course[] = [
    { name: 'ADF301', color: 'bg-sky-400/50', startDate: '2025-07-01', gradDate: '2026-02-01', raafStart: 15, navyStart: 5, armyStart: 5 },
    { name: 'ADF302', color: 'bg-purple-400/50', startDate: '2025-07-01', gradDate: '2026-04-01', raafStart: 18, navyStart: 7, armyStart: 0 },
    { name: 'ADF303', color: 'bg-yellow-400/50', startDate: '2025-07-01', gradDate: '2026-02-01', raafStart: 20, navyStart: 5, armyStart: 0 },
    { name: 'FIC 210', color: 'bg-pink-400/50', startDate: '2025-10-01', gradDate: '2026-04-01', raafStart: 4, navyStart: 0, armyStart: 0 },
];
```

**Type Definition:**
```typescript
export interface Course {
  name: string;
  color: string;
  startDate: string;
  gradDate: string;
  raafStart: number;
  navyStart: number;
  armyStart: number;
}
```

### 6.2 Course Data Migration Impact

**Course data is ALSO hardcoded.**

**Current Usage:**
- Used for UI display (course colors, names)
- Used for filtering trainees
- Trainees have a `course` field referencing course name

**Migration Impact:**
- **Low impact on NEO build algorithm** - course data is not used in scheduling logic
- **Medium impact on UI** - need to fetch from database
- **Can be migrated independently** of LMPs

---

## Section 7: Master LMP Data

### 7.1 What is Master LMP?

"Master LMP" refers to the complete syllabus with all training events for a course type:
- BPC+IPC (Basic Pilot Course + Instrument Pilot Course)
- FIC (Flight Instructor Course)
- WSO (Weapons Systems Officer)
- OFI (Operational Flying Instructor)
- Staff CAT (Staff Continuous Training)

**Currently:**
- All Master LMPs are hardcoded in `mockData.ts`
- Each event has a `courses` field indicating which courses it belongs to
- Example: `createSyllabusItem('BGF1', '...', ['BPC+IPC'])`

### 7.2 Master LMP in Database?

**NOT CURRENTLY IN DATABASE.**

To migrate Master LMPs to Prisma, you would need:

1. **New Prisma Model:**
```prisma
model SyllabusItem {
  id                String   @id @default(cuid())
  code              String   @unique
  description       String
  phase             String
  module            String
  dayNight          String
  prerequisites     String[] // Array of prerequisite codes
  totalEventHours   Float
  flightOrSimHours  Float
  duration          Float
  preFlightTime     Float
  postFlightTime    Float
  type              String   // Flight, FTD, Ground School
  sortieType        String?
  twrDiReqd         String?
  cctOnly           String?
  methodOfDelivery  String[]
  courses           String[] // Array of course names
  lmpType           String?  // Master LMP, Staff CAT
  isRemedial        Boolean  @default(false)
  sequence          Int      // For ordering
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}
```

2. **Migration script** to populate from hardcoded data
3. **Code changes** to fetch from database (see Section 5.3)

---

## Section 8: Recommendation

### 8.1 CRITICAL WARNING

**⚠️ DO NOT MIGRATE LMPs TO PRISMA WITHOUT CODE CHANGES**

**Why?**
1. LMPs are currently hardcoded in `mockData.ts`
2. NEO build algorithm reads LMPs from memory (React state)
3. NO database query mechanism exists for LMP data
4. Migrating to Prisma without code changes will result in:
   - **Empty LMP data** (algorithm will have no syllabus to work with)
   - **Broken NEO build** (cannot determine next events)
   - **Application failure**

### 8.2 Safe Migration Approach

**Phase 1: Add Database Schema (No Code Changes)**
1. Add `SyllabusItem` model to Prisma schema
2. Run `npx prisma db push`
3. Create migration script to populate from hardcoded data
4. **STOP** - Do not change any frontend code yet

**Phase 2: Create API Route (No Code Changes)**
1. Create `app/api/syllabus/route.ts`
2. Implement GET endpoint to fetch syllabus data
3. Test endpoint returns correct data
4. **STOP** - Do not change App.tsx yet

**Phase 3: Update Frontend (Code Changes Required)**
1. Add `useEffect` in App.tsx to fetch syllabus on mount
2. Convert database records to `SyllabusItemDetail` format
3. Store in `traineeLMPs` state (same as current)
4. Add loading state while fetching
5. Test NEO build still works

**Phase 4: Migrate Course Data**
1. Add `Course` model to Prisma schema
2. Create migration script
3. Fetch from database in App.tsx
4. Lower priority than LMPs

### 8.3 What CAN Be Migrated Now

**Safe to migrate to Railway database NOW (no code changes needed):**

1. ✅ **User accounts** - Already using database
2. ✅ **Schedule data** - Already using database
3. ✅ **Personnel records** - Already using database
4. ✅ **Aircraft information** - Already using database
5. ✅ **Cancellation history** - Already using database
6. ✅ **Audit logs** - Already using database

**These are already in the database schema and being used correctly.**

### 8.4 What MUST Stay Hardcoded Until Phased Migration

**CANNOT migrate yet without breaking the app:**

1. ❌ **LMPs (Lesson Management Plans)** - Will break NEO build algorithm
2. ❌ **Master Syllabus data** - Will break NEO build algorithm
3. ❌ **Course data** - Will break UI and trainee filtering

---

## Section 9: Implementation Checklist

### 9.1 Before Starting Migration

- [ ] Confirm user understands LMPs are hardcoded
- [ ] Confirm user accepts code changes are required
- [ ] Get Railway DATABASE_URL
- [ ] Test database connection
- [ ] Backup current hardcoded data

### 9.2 Phase 1: Database Schema (Low Risk)

- [ ] Add `SyllabusItem` model to Prisma schema
- [ ] Add `Course` model to Prisma schema
- [ ] Run `npx prisma generate`
- [ ] Run `npx prisma db push`
- [ ] Verify tables created in Railway database

### 9.3 Phase 2: Data Migration (Medium Risk)

- [ ] Create migration script for syllabus items
- [ ] Run migration script
- [ ] Verify data in Railway database
- [ ] Create migration script for courses
- [ ] Run migration script
- [ ] Verify course data in Railway database

### 9.4 Phase 3: API Routes (Medium Risk)

- [ ] Create `app/api/syllabus/route.ts`
- [ ] Test GET endpoint
- [ ] Create `app/api/courses/route.ts`
- [ ] Test GET endpoint

### 9.5 Phase 4: Frontend Integration (High Risk)

- [ ] Update App.tsx to fetch syllabus on mount
- [ ] Add loading state
- [ ] Add error handling
- [ ] Update App.tsx to fetch courses on mount
- [ ] Test NEO build algorithm
- [ ] Test UI components using syllabus data
- [ ] Test trainee filtering by course

### 9.6 Phase 5: Cleanup (Low Risk)

- [ ] Remove hardcoded data from mockData.ts (optional)
- [ ] Update documentation
- [ ] Deploy to production
- [ ] Monitor for issues

---

## Section 10: Risk Assessment

### 10.1 Migration Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|-----------|
| Breaking NEO build algorithm | HIGH | CRITICAL | Phased approach, thorough testing |
| Data loss during migration | MEDIUM | HIGH | Backup before migration |
| Performance degradation | MEDIUM | MEDIUM | Load once at startup |
| Type mismatches between DB and TypeScript | MEDIUM | HIGH | Careful schema design |
| Rollback complexity | LOW | MEDIUM | Keep old code until verified |

### 10.2 Failure Scenarios

**Scenario 1: Frontend cannot fetch LMPs**
- **Symptom:** NEO build fails with "no next events"
- **Fix:** Fallback to hardcoded data
- **Rollback:** Revert to using `ESL_DATA.traineeLMPs`

**Scenario 2: Database schema mismatch**
- **Symptom:** TypeScript compilation errors
- **Fix:** Update types to match database
- **Rollback:** Restore old Prisma schema

**Scenario 3: Data corruption during migration**
- **Symptom:** Missing or incorrect syllabus items
- **Fix:** Re-run migration script
- **Rollback:** Restore from backup

---

## Conclusion

### Final Verdict

**LMPs are currently HARD-CODED in TypeScript. Migrating them to Prisma database WILL require code changes to the NEO build algorithm.**

**Do not proceed with LMP migration until:**
1. You understand the code changes required
2. You have approved the phased migration approach
3. You are prepared for potential downtime during frontend integration
4. You have tested thoroughly in development environment

**What you CAN do now:**
- ✅ Migrate users, schedules, personnel, aircraft to Railway (already in database)
- ✅ Add Prisma models for SyllabusItem and Course (schema only)
- ✅ Create migration scripts to populate data (without using it yet)

**What you MUST do before using database LMPs:**
- ❌ Create API routes to fetch LMP data
- ❌ Update App.tsx to fetch LMPs from API
- ❌ Test NEO build algorithm thoroughly
- ❌ Have rollback plan ready

---

**Report Generated:** 2025-01-09
**Analyzed By:** SuperNinja AI Agent
**Codebase Version:** DFP-NEO Platform v1.0